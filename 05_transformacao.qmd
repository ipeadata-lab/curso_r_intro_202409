---
# Manipulando dados com dplyr
title: "Transformando dados"
---


## Introdução

Primeiramente, precisamos carregar o pacote `tidyverse` e a base de dados que vamos utilizar. A base de dados é a tabela 4092 do SIDRA, que apresenta dados sobre "pessoas de 14 anos ou mais de idade por condição em relação à força de trabalho e condição de ocupação", e foi baixada previamente (em [Importando dados](03_importacao.html#pacote-sidrar)).

```{r}
#| message: false
library(tidyverse)
dados_brutos <- read_rds("dados/sidrar_4092_bruto.rds")
```

## Padronizar nome das colunas

É uma boa prática padronizar o nome das colunas de um data frame. Assim evitamos problemas de encoding, facilitamos a legibilidade do código e evitamos possíveis erros ao acessar as colunas.

O pacote `janitor` possui a função `clean_names()`, que padroniza os nomes das colunas de um *data frame*. Ele substitui espaços por *underline* (`_`), remove caracteres especiais, e transforma o texto em minúsculo, garantindo maior consistência ao lidar com os dados. Isso evita erros ao acessar colunas.

```{r}
#| message: false
library(janitor)
```

```{r}
# checar nome das colunas da base de dados
names(dados_brutos)

# limpar nomes das colunas da base de dados, e salvar em um novo objeto
dados_renomeados <- clean_names(dados_brutos)

# checar nome das colunas da base de dados renomeada
names(dados_renomeados)
```

## Linhas, colunas e objetivo de análise

Uma pergunta que é sempre importante ter em mente ao analisar dados é: O que cada linha representa? Na estatística, esse é o conceito da **unidade amostral**, ou **unidade observacional**.

O objeto `dados_brutos` apresenta uma linha para cada combinação das seguintes variáveis:

  - `Trimestre (Código)` / `Trimestre`

  - `Unidade da Federação` / `Unidade da Federação (Código)`

  - `Variável` / `Variável (Código)`
  
  - `Condição em relação à força de trabalho e condição de ocupação` e `Condição em relação à força de trabalho e condição de ocupação (Código)`

Podemos consultar os valores distintos possíveis no R, para garantir que estamos selecionando corretamente os valores de interesse.

As variáveis disponíveis na base de dados, e suas unidades de medida são:

```{r}
distinct(
  # base de dados
  dados_renomeados, 
  # colunas que queremos bucar os valores distintos 
  variavel, unidade_de_medida
)
```

Podemos observar, cada linha representa uma combinação de trimestre, unidade da federação e variável. 

Outras perguntas relevantes ao analisar dados são:

  - Qual é a pergunta que eu quero responder com esses dados?
  - Quais são as variáveis que eu preciso para responder essa pergunta?

Neste capítulo, vamos explorar as funções de transformação de dados do pacote `dplyr`, a partir da pergunta norteadora abaixo:

> Considerando que a tabela 4092 apresenta dados sobre "pessoas de 14 anos ou mais de idade por condição em relação à força de trabalho e condição de ocupação", qual é a taxa de desocupação de cada estado e região do Brasil ao longo do tempo?


## Filtrando linhas

Para responder à pergunta norteadora, não precisamos de todas as variáveis presentes na base de dados. Podemos **filtrar** as linhas que são relevantes para a análise, escolhendo as variáveis de interesse.

Nesse caso, podemos filtrar os dados onde a variável é igual à `"Pessoas de 14 anos ou mais de idade"`.

```{r}
dados_filtrados <- filter(
  # base de dados
  dados_renomeados,
  # condição de filtro
  variavel == "Pessoas de 14 anos ou mais de idade"
)
```

Para verificar se o filtro foi feito corretamente, podemos checar o número de linhas de cada base de dados:

```{r}
nrow(dados_renomeados)
nrow(dados_filtrados)
```

Podemos verificar também os valores distintos para as colunas `variavel` e `unidade_de_medida` na base de dados `dados_filtrados`:

```{r}
distinct(
  # base de dados
  dados_filtrados, 
  # colunas que queremos bucar os valores distintos 
  variavel, unidade_de_medida
)
```

Agora sabemos que a base de dados `dados_filtrados` contém apenas dados sobre a variável `"Pessoas de 14 anos ou mais de idade"`, e que a unidade de medida da coluna `valor` é mil pessoas.

## Selecionando colunas

Algumas colunas não são relevantes para responder à pergunta norteadora. Podemos **selecionar** apenas as colunas que vamos utilizar através da função `select()`:

```{r}
dados_selecionados <- select(
  # base de dados
  dados_filtrados, 
  # colunas que queremos manter
  unidade_da_federacao,
  unidade_da_federacao_codigo,
  trimestre,
  trimestre_codigo,
  condicao_em_relacao_a_forca_de_trabalho_e_condicao_de_ocupacao,
  valor
)

dados_selecionados
```

Podemos renomear colunas com a função `rename()`. Vamos renomear algumas colunas para facilitar o uso posteriormente:

```{r}
dados_renomeados_2 <- rename(
  # base de dados
  dados_selecionados, 
  # colunas que queremos renomear: novo_nome = nome_atual
  condicao = condicao_em_relacao_a_forca_de_trabalho_e_condicao_de_ocupacao,
  valor_mil_pessoas = valor,
  uf = unidade_da_federacao,
  uf_codigo = unidade_da_federacao_codigo
)

glimpse(dados_renomeados_2)
```

## Transformando a tabela

Ainda considerando nossa pergunta norteadora, queremos calcular a taxa de desocupação de cada estado e região do Brasil ao longo do tempo. Para isso, é mais fácil trabalhar com a tabela onde cada linha represente uma UF por trimestre, e as categorias da variável `condicao` sejam transformadas em colunas. 

Para fazer essa transformação, podemos usar a função `pivot_wider()`.

A função `pivot_wider()` é útil quando queremos reorganizar uma tabela, transformando variáveis categóricas em novas colunas. Essa estrutura facilita cálculos comparativos e análises entre as diferentes categorias.

Por exemplo, no formato atual (dados longos), temos uma linha para cada combinação de UF, trimestre e condição de ocupação. Ao usarmos `pivot_wider()`, vamos transformar a tabela para que cada linha represente uma UF por trimestre, e as diferentes condições de ocupação (empregado, desocupado, etc.) se tornem colunas.

```{r}
dados_largos <- pivot_wider(
  # base de dados
  dados_renomeados_2, 
  # nome da coluna de onde os nomes das novas colunas serão extraídos
  names_from = condicao, 
  # nome da coluna de onde os valores das novas colunas serão extraídos 
  values_from = valor_mil_pessoas, 
  # podemos adicionar um texto como prefixo. nesse caso, isso é opcional, 
  # mas é útil para ficar claro qual é a unidade de medida das variáveis
  names_prefix = "mil_pessoas_"
)
```

```{r}
glimpse(dados_largos)
```

Agora temos uma tabela onde cada linha representa uma UF por trimestre, e as categorias da variável `condicao` se tornaram colunas. Porém agora temos colunas com nomes que estão com caracteres especiais, e podemos arrumar isso com a função `clean_names()`.

```{r}
dados_largos_renomeados <- clean_names(dados_largos)
glimpse(dados_largos_renomeados)
```

::: callout-info
As funções `pivot_longer()` e `pivot_wider()` são usadas para alternar entre dados 'longos' e 'largos'. Normalmente, dados longos são mais fáceis de visualizar, enquanto dados largos são melhores para realizar cálculos comparativos entre categorias. Para cada análise, sempre existe um formato mais apropriado a considerar.
:::


## Criando e transformando colunas

Para criar novas colunas, ou transformar colunas que já existem, podemos usar a função `mutate()`.

As variáveis `uf_codigo` e `trimestre_codigo` estão armazenadas como valores numéricos. No entanto, como não realizaremos operações matemáticas com esses valores, é mais apropriado transformá-los em fatores, o que facilita a análise e previne erros em cálculos futuros.

Existem várias funções para transformar variáveis de um tipo para outro, como `as.factor()`, `as.character()`, `as.numeric()`, `as.Date()`,  etc.

```{r}
dados_tipo <- mutate(
  # base de dados
  dados_largos_renomeados,
  # nova variável: 
  # nome_da_coluna = o que queremos calcular
  uf_codigo = as.factor(uf_codigo),
  trimestre_codigo = as.factor(trimestre_codigo)
)
```


Para calcular a taxa de desocupação, precisamos criar uma nova variável representando a proporção de pessoas desocupadas em relação ao total de pessoas economicamente ativas.

```{r}
dados_com_proporcao <- mutate(
  # base de dados
  dados_tipo,
  # nova variável: 
  # nome_da_coluna = o que queremos calcular
  prop_desocupacao = (mil_pessoas_forca_de_trabalho_desocupada / mil_pessoas_forca_de_trabalho)*100,
)
```


## Ordenando as linhas

A base atual está ordada por trimestre e código da unidade da federação. Para facilitar a análise, podemos ordenar as linhas segundo a proporção de desocupação calculada no passo anterior, usando a função `arrange()`:

```{r}
arrange(
  # base de dados
  dados_com_proporcao,
  # colunas que queremos usar ordenar
  prop_desocupacao
)
```

A função `arrange()` ordena, por padrão, de forma crescente. Podemos ordenar de forma decrescente, utilizando a função `desc()` junto à coluna que queremos ordenar de forma decrescente:

```{r}
arrange(
  # base de dados
  dados_com_proporcao,
  # colunas que queremos usar ordenar
  desc(prop_desocupacao)
)
```

Nesse caso, as linhas ficaram ordenadas de forma decrescente, de acordo com a proporção de desocupação. Porém os trimestres não estão ordenados! A função `arrange()` permite que ordenemos por mais de uma coluna, e a ordem de prioridade é dada pela ordem em que as colunas são passadas para a função:

```{r}
dados_ordenados <- arrange(
  # base de dados
  dados_com_proporcao,
  # colunas que queremos usar ordenar
  trimestre_codigo, desc(prop_desocupacao)
)

glimpse(dados_ordenados)
```

Agora temos a base de dados ordenada por trimestre, e dentro de cada trimestre, por proporção de desocupação (de forma descrecente).

## Pipe - Encadeando funções

Nos exemplos anteriores, utilizamos uma função por vez, para facilitar a compreensão de cada etapa. No entanto, à medida que nos familiarizamos com as funções, podemos encadear várias delas em um único fluxo de código usando o operador *pipe* (`%>%` ou `|>`). Isso torna o código mais conciso e elimina a criação de objetos intermediários desnecessários.

Podemos reescrever os códigos anteriores usando o operador pipe para encadear as funções. Isso permite que criemos menos objetos intermediários (como os que criamos anteriormente: `dados_renomeados`, `dados_filtrados`, `dados_selecionados`, etc.). Porém, é importante ter cuidado para não criar sequências muito longas e difíceis de entender.

No exemplo abaixo, criamos menos objetos intermediários, e encadeamos as funções usadas anteriormente usando o pipe: 

```{r}
dados_filtrados_selecionados <- dados_brutos |>
  # limpando os nomes das colunas
  clean_names() |>
  # filtrando as linhas
  filter(variavel == "Pessoas de 14 anos ou mais de idade") |>
  # selecionando as colunas
  select(
    unidade_da_federacao,
    unidade_da_federacao_codigo,
    trimestre,
    trimestre_codigo,
    condicao_em_relacao_a_forca_de_trabalho_e_condicao_de_ocupacao,
    valor
  ) |>
  # renomeando as colunas
  rename(
    condicao = condicao_em_relacao_a_forca_de_trabalho_e_condicao_de_ocupacao,
    valor_mil_pessoas = valor,
    uf = unidade_da_federacao,
    uf_codigo = unidade_da_federacao_codigo
  )

dados_largos <- dados_filtrados_selecionados |>
  # transformando para formato largo
  pivot_wider(
    names_from = condicao,
    values_from = valor_mil_pessoas,
    names_prefix = "mil_pessoas_"
  ) |>
  # limpando o nome das colunas novamente
  clean_names()

  
  
dados_preparados <- dados_largos |>  
  # transformando as variáveis 
  mutate(
    uf_codigo = as.factor(uf_codigo),
    trimestre_codigo = as.factor(trimestre_codigo),
    prop_desocupacao = (
      mil_pessoas_forca_de_trabalho_desocupada / mil_pessoas_forca_de_trabalho
    ) * 100,
  ) |>
  # ordenando a base de dados
  arrange(trimestre_codigo, desc(prop_desocupacao))
```

```{r}
glimpse(dados_preparados)
```



## Unindo duas bases de dados

Unir duas tabelas é algo comum em análises de dados. Usamos operações do tipo *join* para combinar duas tabelas, utilizando uma ou mais colunas como "chave". As colunas do tipo chave têm valores comuns nas duas tabelas e são usadas para identificar as linhas correspondentes entre elas.

O  pacote `{dplyr}` fornece um conjunto de funções para realizar diferentes tipos de uniões, como `left_join()`, `inner_join()`, `full_join()`, entre outras.

A função `left_join()` é a mais frequentemente usada: ela mantém todas as linhas da primeira tabela e adiciona colunas da segunda tabela onde houver correspondência.

Um exemplo comum de uso é quando temos dados por município ou estado, e desejamos visualizar esses dados em um mapa. Para isso, precisamos de informações geoespaciais, como a delimitação geográfica de cada município ou estado. Podemos usar o `left_join()` para combinar esses dados geoespaciais com os dados que queremos visualizar.

Vamos usar o pacote `{geobr}` para carregar as geometrias dos estados brasileiros.

::: callout-tip
O pacote `{geobr}` facilita o acesso a dados geoespaciais do Brasil, como estados, municípios e outras divisões administrativas. Ele é muito útil quando queremos fazer análises geoespaciais, já que oferece dados geográficos prontos para uso.

Podemos utilizar a função `read_state()` para carregar as geometrias dos estados brasileiros. Isso nos permite combinar essas geometrias com outros dados, como taxas de desocupação, e criar mapas que facilitam a visualização de padrões regionais.
:::

```{r}
#| message: false
library(geobr)
geo_estados <- read_state(showProgress = FALSE)
glimpse(geo_estados)
```


O `left_join()` é usado aqui para combinar os dados do SIDRA com os dados das delimitações das UFs. Cada linha do nosso dataset de desocupação será associada à respectiva geometria da UF, permitindo visualizarmos as proporções de desocupação por UF em um mapa. Esse tipo de operação é comum quando queremos identificar padrões regionais.


É importante garantir que as colunas usadas na combinação de tabelas (o argumento `by` do `left_join()`) tenham o mesmo tipo de dado. Podemos verificar o tipo de dado de cada coluna com a função `class()`:

```{r}
class(geo_estados$code_state)
class(dados_ordenados$uf_codigo)
```

Neste caso, as colunas que queremos usar como chave são de tipos diferentes (numérico e fator), O `left_join()` não conseguirá fazer a correspondência corretamente, e a função gerará um erro:

```{r}
#| error: true
left_join(geo_estados, dados_ordenados, by = join_by(code_state == uf_codigo))
```

No exemplo, podemos transformar a coluna `code_state` em fator usando `mutate()`. Assim, garantimos que as colunas usadas no argumento `by` sejam do mesmo tipo e possam ser corretamente combinados.

```{r}
dados_geo <- geo_estados |> 
  mutate(code_state = as.factor(code_state)) |> 
  left_join(dados_ordenados, by = join_by(code_state == uf_codigo))

glimpse(dados_geo)
```

Agora temos uma base de dados que combina os dados do SIDRA com as geometrias dos estados brasileiros.

Combinar dados dessa forma nos permite fazer visualizações geoespaciais, como um mapa de calor das taxas de desocupação por estado. Isso facilita a identificação de padrões regionais, ajudando na interpretação dos dados.

Não falaremos nesse momento sobre como criar visualizações e mapas, pois isso será abordado em aulas futuras. Mas podemos adiantar um exemplo de como criar um mapa apresentando as proporções de desocupação por estado:

```{r}
#| label: geobr-mapa
#| echo: true
#| code-fold: true
dados_geo |> 
  filter(trimestre_codigo == "202402") |>
  ggplot() +
  geom_sf(aes(fill = prop_desocupacao)) +
  theme_light() +
  scale_fill_viridis_c() +
  labs(title = "Proporção de desocupação por UF no 2º trimestre de 2024",
       fill = "Proporção de desocupação (%)") +
  theme(legend.position = "bottom")
```


## Salvando a base de dados preparada

Por fim, podemos salvar a base de dados preparada para usar nas próximas etapas. Assim não precisamos repetir todo o processo de limpeza e transformação de dados a cada vez que quisermos fazer uma análise.

É recomendável salvar a base de dados em um formato que preserve a estrutura dos dados, como `.rds`.

```{r}
#| eval: false
# Criando a pasta "dados_output" caso ela ainda não exista
fs::dir_create("dados_output")
# Salvando os dados preparados
write_rds(dados_preparados, "dados_output/sidra_4092_arrumado.rds")
```


## Sugestões de materiais

- Livro [R para Ciência de Dados 2ed](https://cienciadedatos.github.io/pt-r4ds/):
  - [Transformação de dados](https://cienciadedatos.github.io/pt-r4ds/data-transform.html)
  - [Organização de dados](https://cienciadedatos.github.io/pt-r4ds/data-tidy.html)