[
  {
    "objectID": "02_conceitos_basicos_r.html",
    "href": "02_conceitos_basicos_r.html",
    "title": "Conceitos básicos",
    "section": "",
    "text": "Aviso\n\n\n\nPágina em construção! Em breve.",
    "crumbs": [
      "Materiais",
      "Conceitos básicos"
    ]
  },
  {
    "objectID": "11_censobr_microdados.html",
    "href": "11_censobr_microdados.html",
    "title": "Microdados do Censo",
    "section": "",
    "text": "A Tabela 1 apresenta abaixo todas as bases de dados do censo que você consegue acessar com o {censobr}.\nTabela 1. Funções de dados disponíveis no {censobr}\n\n\n\n  \n  \n    \n\n\n\n\nFunção\nOrigem\nUnidade\nDefinição\nDisponibilidade\n\n\n1960\n70\n80\n91\n2000\n10\n22\n\n\n\n\nread_population()\nAmostra\nMicrodado\nLê os microdados de pessoas\nX\nX\nX\nX\nX\nX\nem breve\n\n\nread_households()\nAmostra\nMicrodado\nLê os microdados de domicílios\nX\nX\nX\nX\nX\nX\nem breve\n\n\nread_families()\nAmostra\nMicrodado\nLê os microdados de famílias do censo de 2000\n\n\n\nX\n\n\n\n\n\nread_emigration()\nAmostra\nMicrodado\nLê os microdados de emigração\n\n\n\n\n\nX\nem breve\n\n\nread_mortality()\nAmostra\nMicrodado\nLê os microdados de mortalidade\n\n\n\n\n\nX\nem breve\n\n\nread_tracts()\nUniverso\nSetor Censitário\nLê os dados do Universo agregados por setores censitários\n\n\n\n\nem breve\nX\nem breve\n\n\n\nTodas as funções do {censobr} para leitura de microdados possuem a mesma estrutra (sintaxe), o que permite o usuário baixar os dados de maneira fácil e intuitiva com um único comando. As funções possuem os seguintes parâmetros:\n\nread_households(\n  year,          # ano de referência do censo\n  columns,       # seleciona colunas que devem ser lidas\n  add_labels,    # adiciona os 'labels' das variáveis categóricas\n  as_data_frame, # retorna resultado como um `Arrow DataSet` ou `data.frame`\n  showProgress,  # mostra barra de progresso do download\n  cache          # salva arquivo em cache para rapida leitura posteriormente\n  )\n\n\n\n\n\n\n\nCache local dos dados\n\n\n\nA primeira vez que o usuário executa uma função, o {censobr} fará o download dos dados e os armazenará localmente numa pasta do pacote. Dessa forma, os dados precisam ser baixados apenas uma vez. Mais informações na seção Cache de Dados abaixo.",
    "crumbs": [
      "Explorando o Censo Demográfico",
      "Microdados do Censo"
    ]
  },
  {
    "objectID": "11_censobr_microdados.html#dados-disponíveis-no-censobr",
    "href": "11_censobr_microdados.html#dados-disponíveis-no-censobr",
    "title": "Microdados do Censo",
    "section": "",
    "text": "A Tabela 1 apresenta abaixo todas as bases de dados do censo que você consegue acessar com o {censobr}.\nTabela 1. Funções de dados disponíveis no {censobr}\n\n\n\n  \n  \n    \n\n\n\n\nFunção\nOrigem\nUnidade\nDefinição\nDisponibilidade\n\n\n1960\n70\n80\n91\n2000\n10\n22\n\n\n\n\nread_population()\nAmostra\nMicrodado\nLê os microdados de pessoas\nX\nX\nX\nX\nX\nX\nem breve\n\n\nread_households()\nAmostra\nMicrodado\nLê os microdados de domicílios\nX\nX\nX\nX\nX\nX\nem breve\n\n\nread_families()\nAmostra\nMicrodado\nLê os microdados de famílias do censo de 2000\n\n\n\nX\n\n\n\n\n\nread_emigration()\nAmostra\nMicrodado\nLê os microdados de emigração\n\n\n\n\n\nX\nem breve\n\n\nread_mortality()\nAmostra\nMicrodado\nLê os microdados de mortalidade\n\n\n\n\n\nX\nem breve\n\n\nread_tracts()\nUniverso\nSetor Censitário\nLê os dados do Universo agregados por setores censitários\n\n\n\n\nem breve\nX\nem breve\n\n\n\nTodas as funções do {censobr} para leitura de microdados possuem a mesma estrutra (sintaxe), o que permite o usuário baixar os dados de maneira fácil e intuitiva com um único comando. As funções possuem os seguintes parâmetros:\n\nread_households(\n  year,          # ano de referência do censo\n  columns,       # seleciona colunas que devem ser lidas\n  add_labels,    # adiciona os 'labels' das variáveis categóricas\n  as_data_frame, # retorna resultado como um `Arrow DataSet` ou `data.frame`\n  showProgress,  # mostra barra de progresso do download\n  cache          # salva arquivo em cache para rapida leitura posteriormente\n  )\n\n\n\n\n\n\n\nCache local dos dados\n\n\n\nA primeira vez que o usuário executa uma função, o {censobr} fará o download dos dados e os armazenará localmente numa pasta do pacote. Dessa forma, os dados precisam ser baixados apenas uma vez. Mais informações na seção Cache de Dados abaixo.",
    "crumbs": [
      "Explorando o Censo Demográfico",
      "Microdados do Censo"
    ]
  },
  {
    "objectID": "11_censobr_microdados.html#trabalhando-com-dados-maior-do-que-a-ram",
    "href": "11_censobr_microdados.html#trabalhando-com-dados-maior-do-que-a-ram",
    "title": "Microdados do Censo",
    "section": "Trabalhando com dados maior do que a RAM",
    "text": "Trabalhando com dados maior do que a RAM\n\n\n\n\nÉ muito comum que os microdados do censo brasileiro sejam grandes demais para serem carregados na memória RAM do usuário. Para resolver esse problema, o {censobr} foi construído sobre a plataforma Arrow e arquivos em formato .parquet, o que permite que o usuário trabalhe de maneira eficiente até mesmo com bases de dados muito grandes utilizando funções já bem conhecidas do pacote {dplyr}.\nVamos então partir para exemplos na prática, e começar carregando as bibliotecas que usamos.\n\n# carrega bibliotecas\nlibrary(censobr)\nlibrary(arrow)\nlibrary(dplyr)\nlibrary(ggplot2)",
    "crumbs": [
      "Explorando o Censo Demográfico",
      "Microdados do Censo"
    ]
  },
  {
    "objectID": "11_censobr_microdados.html#dados-de-população",
    "href": "11_censobr_microdados.html#dados-de-população",
    "title": "Microdados do Censo",
    "section": "Dados de população",
    "text": "Dados de população\nNeste exemplo, nós vamos criar um gráfico da pirâmica populacional do Brasil no ano de 2010. O primeiro passo é usar a função read_population() para carregar os microdados de população.\nO comportamento padrão das funções do {censobr} é retornar todas as variáveis das bases de dados. No entanto, como vamos fazer uma análise simples, o mais eficiente é passarmos um vetor com os nomes das colunas que vamos utilizar. Neste caso, usaremos somente as variáveis de peso amostral, sexo e idade (códigos \"V0010\", \"V0601\" e \"V6036\", respectivamente). No último capítulo do curso a gente vai ver como baixar os dicionários variáveis dos censos.\n\npop &lt;- read_population(\n  year = 2010,\n  columns = c('V0010', 'V0601', 'V6036'),\n  add_labels = 'pt',\n  showProgress = FALSE\n  )\n\nclass(pop)\n\n\n1\n\nAumentando eficiência ao ler apenas as colunas que vamos usar\n\n2\n\nAdicionando os ‘labels’ em Português das variáveis categóricas.\n\n\n\n\n[1] \"arrow_dplyr_query\"\n\n\nAo rodar o comando nrow(pop), você verá que a tabela de microdados de população do Censo de 2010 tinha mais de vinte milhões de observações (20.635.472), mas essas observações não estão carregadas na sua memória RAM. Isso porque, por padrão, a saída da função é um \"arrow_dplyr_query\" ou \"ArrowObject\". Isso permite que você trabalhe com os dados do censo de maneira super rápida e eficiente, mesmo que a tabela de dados seja grande demais para a memória do seu computador. Note que se você passar o parâmetro as_data_frame = TRUE, a função carregará os dados como um data.frame na memória RAM. Atenção: isso pode fazer com que a sessão do R trave em ambientes com pouca memória.\nEsse output em arrow pode ser analisado de maneira similar a como se analisaria um data.frame utilizando-se funções do pacote {dplyr}. Uma diferença, no entanto, é que as operações somente são executadas e resultados extraídos quando o usuário roda a função dplyr::collect().\nNeste exemplo, abaixo, nós visualizamos as primeiras linhas 6 da tabela de dados com head(pop), e somente essas poucas observações são carregas para memória com o commando collect():\n\nhead(pop) |&gt; \n  collect()\n\n     V0010     V0601 V6036\n1 8.083000 Masculino     8\n2 9.718624 Masculino    28\n3 9.718624  Feminino    19\n4 9.718624  Feminino     3\n5 9.513442  Feminino    61\n6 9.513442 Masculino    58\n\n\nO próximo passo para criamos nossa pirâmide populacional é criar um variável categória com grupos de idade. No exemplo abaix, nós utilizadmos grupos de 5 anos.\n\npop &lt;- pop |&gt;\n  mutate(\n    age_group = dplyr::case_when(\n      V6036 &lt;= 04              ~ \"00-05\",\n      V6036 &gt;= 05 & V6036 &lt; 10 ~ \"05-10\",\n      V6036 &gt;= 10 & V6036 &lt; 15 ~ \"10-15\",\n      V6036 &gt;= 15 & V6036 &lt; 20 ~ \"15-20\",\n      V6036 &gt;= 20 & V6036 &lt; 25 ~ \"20-25\",\n      V6036 &gt;= 25 & V6036 &lt; 30 ~ \"25-30\",\n      V6036 &gt;= 30 & V6036 &lt; 35 ~ \"30-35\",\n      V6036 &gt;= 35 & V6036 &lt; 40 ~ \"35-40\",\n      V6036 &gt;= 40 & V6036 &lt; 45 ~ \"40-45\",\n      V6036 &gt;= 45 & V6036 &lt; 50 ~ \"45-50\",\n      V6036 &gt;= 50 & V6036 &lt; 55 ~ \"50-55\",\n      V6036 &gt;= 55 & V6036 &lt; 60 ~ \"55-60\",\n      V6036 &gt;= 60 & V6036 &lt; 65 ~ \"60-65\",\n      V6036 &gt;= 65 & V6036 &lt; 70 ~ \"65-70\",\n      V6036 &gt;= 70              ~ \"70+\"\n      ))\n\nhead(pop) |&gt; \n  collect()\n\n     V0010     V0601 V6036 age_group\n1 4.732128  Feminino     4     00-05\n2 4.283271 Masculino    19     15-20\n3 4.283271 Masculino    68     65-70\n4 5.922211  Feminino    26     25-30\n5 5.922211 Masculino     0     00-05\n6 5.922211  Feminino     3     00-05\n\n\nE em seguida, nós só precisamos somar o número de homens e mulheres em cada grupo de idade. Para isso, nós somamos os valores da variável de peso amostral V0010 em cada grupo. Repare que ao chamarmos a função collect(), o código é executado e retorna um data.frame com a contagem de pessoas por sexo e faixa de idade. Repare que nós processamos todos os mais de 20 milhões de registro do censo, mas só precisamos carregar na memória essa tabela com 30 observações.\n\n# cacula tabela de contagem de pessoas por idade\npiramide_df &lt;- pop |&gt;\n               group_by(V0601, age_group) |&gt;\n               summarise(pop_count = sum(V0010)) |&gt;\n               collect()\n\nhead(piramide_df)\n\n# A tibble: 6 × 3\n# Groups:   V0601 [2]\n  V0601     age_group pop_count\n  &lt;chr&gt;     &lt;chr&gt;         &lt;dbl&gt;\n1 Feminino  10-15      8440040.\n2 Masculino 45-50      5692722.\n3 Feminino  00-05      6781032.\n4 Feminino  55-60      4371889.\n5 Masculino 50-55      4825839.\n6 Feminino  25-30      8644127.\n\n\nPronto, no último passo é só fazer o gráfico de pirâmide populacional utilizando o pacote {ggplot2}.\n\nCódigo# remove grupo com idade missing `NA`\npiramide_df &lt;- filter(piramide_df, !is.na(age_group))\n\n# transforma a contagem de mulheres para valores negativos\npiramide_df &lt;- piramide_df |&gt;\n  mutate(pop_count = if_else(V0601 == \"Masculino\", pop_count, -pop_count))\n\n# figura\nggplot(data = piramide_df,\n       aes(x = pop_count / 1000,\n           y = age_group,\n           fill = V0601)) +\n  geom_col() +\n  scale_fill_discrete(name=\"\", type=c(\"#ffcb69\",\"#437297\")) +\n  scale_x_continuous(labels = function(x){scales::comma(abs(x))},\n                     breaks = c(-8000, -4000,0,4000, 8000),\n                     name = \"População (em milhares)\") +\n  theme_classic() +\n  theme(\n    legend.position = \"top\",\n    axis.title.y=element_blank(),\n    panel.grid.major.x = element_line(color = \"grey90\")\n  )\n\n\n\nPirâmide demográfica, Brasil, 2010",
    "crumbs": [
      "Explorando o Censo Demográfico",
      "Microdados do Censo"
    ]
  },
  {
    "objectID": "11_censobr_microdados.html#dados-de-domicílios",
    "href": "11_censobr_microdados.html#dados-de-domicílios",
    "title": "Microdados do Censo",
    "section": "Dados de domicílios",
    "text": "Dados de domicílios\nSaneamento:\nNeste exemplo, nós vamos usar os dados de domicílios do censo de 2010 para calcular qual a proporção de domicílios que estavam conectados à rede de esgoto nos municípios de cada região do Brasil. O primeiro passo é baixar os dados utilizando a função read_households().\n\ndom &lt;- read_households(year = 2010, \n                      showProgress = FALSE)\n\nAgora vamos (1) agrupar as observações por região e município, (2) obter o número de domicílios conectados à rede de esgoto, (3) obter o número total de domicílios, (4) calcular a proporção de domicílios conectados e (5) coletar os resultados.\n\nesg &lt;- dom |&gt; \n        compute() |&gt;\n        group_by(name_region, code_muni) |&gt;\n        summarize(rede = sum(V0010[which(V0207=='1')]),\n                  total = sum(V0010)) |&gt;\n        mutate(cobertura = rede / total) |&gt;\n        collect()\n\nhead(esg)\n\n\n1\n\nAgrupar as observações por região e município\n\n2\n\nObter o número de domicílios conectados à rede de esgoto\n\n3\n\nObter o número total de domicílios\n\n4\n\nCalcular a proporção de domicílios conectados\n\n5\n\nColetar os resultados.\n\n\n\n\n# A tibble: 6 × 5\n# Groups:   name_region [1]\n  name_region  code_muni   rede  total cobertura\n  &lt;chr&gt;            &lt;int&gt;  &lt;dbl&gt;  &lt;dbl&gt;     &lt;dbl&gt;\n1 Centro-oeste   5000203   73.4  4534    0.0162 \n2 Centro-oeste   5000252   10.3  1596.   0.00646\n3 Centro-oeste   5000609 2150.  11012.   0.195  \n4 Centro-oeste   5000708 1705.   7419.   0.230  \n5 Centro-oeste   5000807   35.9  2759.   0.0130 \n6 Centro-oeste   5000856   12.4  3053.   0.00407\n\n\nUma rápida análise da dispersão dos valores com o box-plot abaixo já revela um dos retratos da desigualdade regional brasileira. Em todos municípios da região Norte e quase metade dos municípios da região Nordeste, a gente encontra que menos de 50% dos domicílios estavam conectados à rede de esgoto em 2010. No próximo bloco, nós vamos visualizar como essas diferenças se distribuem espacialmente.\n\nggplot(esg) +\n  geom_boxplot(aes(x=reorder(name_region, -cobertura), y=cobertura, \n                   weight  = rede, color=name_region), \n               show.legend = F, outlier.alpha = 0.1) +\n  scale_y_continuous(labels = scales::percent) +\n  labs(x=\"Região\", y=\"Quantidade de domicílios\\nconectados à rede de esgoto\") +\n  theme_classic()\n\nWarning: Computation failed in `stat_boxplot()`.\nCaused by error in `loadNamespace()`:\n! there is no package called 'quantreg'",
    "crumbs": [
      "Explorando o Censo Demográfico",
      "Microdados do Censo"
    ]
  },
  {
    "objectID": "11_censobr_microdados.html#análise-espacial-com-geobr",
    "href": "11_censobr_microdados.html#análise-espacial-com-geobr",
    "title": "Microdados do Censo",
    "section": "Análise espacial com {geobr}",
    "text": "Análise espacial com {geobr}\nO {geobr} é um pacote para baixar dados espaciais oficiais do Brasil (Pereira e Gonçalves 2019). Ele inclui uma ampla variedade de dados geoespaciais disponíveis em várias escalas geográficas e para diversos anos, como municípios, regiões metropolitanas, biomas, estabelecimentos de saúde, etc (veja a lista completa no site do pacote).",
    "crumbs": [
      "Explorando o Censo Demográfico",
      "Microdados do Censo"
    ]
  },
  {
    "objectID": "11_censobr_microdados.html#integração-entre-censobr-e-geobr",
    "href": "11_censobr_microdados.html#integração-entre-censobr-e-geobr",
    "title": "Microdados do Censo",
    "section": "Integração entre {censobr} e {geobr}",
    "text": "Integração entre {censobr} e {geobr}\n\n\n\n\nTodos os dados do {censobr} são enriquecidos com colunas de geografia, seguindo os padrões de nomenclatura do pacote {geobr} para facilitar a manipulação e a integração de dados espaciais dos censos demográficos do Brasil. As colunas adicionadas são: c('code_muni', 'code_state', 'abbrev_state', 'name_state', 'code_region', 'name_region', 'code_weighting', 'code_tract').\n\nPara criarmos uma mapa com a distribuição espacial da cobertura da rede de esgoto no Brasil, nós vamos primeiro usar o pacote {geobr} para baixar as geometrias dos municípios brasileiros no ano de 2010. Vamos também sobrepor os limites das grandes regiões do país para dar um pouco mais de contexto à figura.\n\nlibrary(geobr)\n\nregioes_df &lt;- read_region(year = 2010,\n                          showProgress = FALSE)\n\nmuni_sf &lt;- read_municipality(year = 2010,\n                             showProgress = FALSE)\n\nhead(muni_sf)\n\nSimple feature collection with 6 features and 4 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -63.61822 ymin: -13.6937 xmax: -60.33317 ymax: -9.66916\nGeodetic CRS:  SIRGAS 2000\n  code_muni             name_muni code_state abbrev_state\n1   1100015 Alta Floresta D'oeste         11           RO\n2   1100023             Ariquemes         11           RO\n3   1100031                Cabixi         11           RO\n4   1100049                Cacoal         11           RO\n5   1100056            Cerejeiras         11           RO\n6   1100064     Colorado Do Oeste         11           RO\n                            geom\n1 MULTIPOLYGON (((-62.2462 -1...\n2 MULTIPOLYGON (((-63.13712 -...\n3 MULTIPOLYGON (((-60.52408 -...\n4 MULTIPOLYGON (((-61.42679 -...\n5 MULTIPOLYGON (((-61.41347 -...\n6 MULTIPOLYGON (((-60.66352 -...\n\n\nAgora nós só precisamos unir os dados espaciais com nossas estimativas utilizando a variável chave code_muni e mapear os resultados.\n\n# merge data\nesg_sf &lt;- dplyr::left_join(muni_sf, esg, by = 'code_muni')\n\n# plot map\nggplot() +\n  geom_sf(data = esg_sf, aes(fill = cobertura), color=NA) +\n  geom_sf(data = regioes_df, color = 'gray20', fill=NA) +\n  labs(title = \"Quantidade de domicílios conectados à rede de esgoto\") +\n  scale_fill_distiller(palette = \"Greens\", direction = 1, \n                       name='Proporção de\\ndomicílios', \n                       labels = scales::percent) +\n  theme_void() +\n  theme(legend.position = 'bottom')\n\n\n\n\n\n\n\nDistribuição espacial do valor do aluguel:\nNo exemplo anterior, nós agregamos os microdados do censo no nível de municípios. Neste próximo exemplo, faremos uma análise espacial no nível de áreas de ponderação. Aqui nós vamos visualizar como o valor do aluguel varia espacialmente na região metropolitana de São Paulo.\nPrimeiro, vamos baixar os municípios da região metropolitana de São Paulo com o {geobr}.\n\nmetro_sp &lt;- geobr::read_metro_area(year = 2010,\n                                     showProgress = FALSE) |&gt; \n              filter(name_metro == \"RM São Paulo\")\n\nTambém precisamos dos polígonos das áreas de ponderação. Com o código abaixo, baixamos todas as áreas de ponderação do estado de São Paulo e, em seguida, mantemos apenas aquelas na região metropolitana de São Paulo.\n\nwt_areas &lt;- geobr::read_weighting_area(code_weighting = \"SP\",\n                                       year = 2010,\n                                       simplified = FALSE,\n                                       showProgress = FALSE)\n\nwt_areas &lt;- filter(wt_areas, code_muni %in% metro_sp$code_muni)\nhead(wt_areas)\n\n\n1\n\nO comportamento padrão do {geobr} é baixar uma versão da malha espacial com geometrias ligeiramente simplificadas (simplified = TRUE) para agilizar o processamento e visualização de dados. Aqui, nós baixamos os dados com geometrias originais devido à escala espacial da visualização dos resultados.\n\n\n\n\nSimple feature collection with 6 features and 7 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -46.73454 ymin: -23.64487 xmax: -46.64756 ymax: -23.53528\nGeodetic CRS:  SIRGAS 2000\n  code_weighting code_muni name_muni code_state abbrev_state code_region\n1  3550308005100   3550308 São Paulo         35           SP           3\n2  3550308005102   3550308 São Paulo         35           SP           3\n3  3550308005101   3550308 São Paulo         35           SP           3\n4  3550308005104   3550308 São Paulo         35           SP           3\n5  3550308005103   3550308 São Paulo         35           SP           3\n6  3550308005106   3550308 São Paulo         35           SP           3\n  name_region                           geom\n1     Sudeste MULTIPOLYGON (((-46.67201 -...\n2     Sudeste MULTIPOLYGON (((-46.67663 -...\n3     Sudeste MULTIPOLYGON (((-46.67257 -...\n4     Sudeste MULTIPOLYGON (((-46.70138 -...\n5     Sudeste MULTIPOLYGON (((-46.69581 -...\n6     Sudeste MULTIPOLYGON (((-46.73454 -...\n\n\nAgora voltamos para a base de dados de domicílios do censo de 2010. Com essa base, nós precisamos calcular o valor médio do aluguel gasto em cada área de ponderação. Note que para isso nós usamos a média do aluguel (variável V2011) ponderada pelo peso do domicílio (variável V0010). Para encontrar esses valores, o código abaixo (1) filtra apenas as observações nos nossos municípios de interesse, (2) computa temporariamente o resultado, (3) agrupa as observações por área de ponderação, (4) calcula o valor médio do aluguel e (5) coleta os resultados.\n\nrent &lt;- dom |&gt;\n        filter(code_muni %in% metro_sp$code_muni) |&gt;\n        compute() |&gt;\n        group_by(code_weighting) |&gt;\n        summarize(avgrent=weighted.mean(x=V2011, w=V0010, na.rm=TRUE)) |&gt;\n        collect()\n\nhead(rent)\n\n\n1\n\nFiltra apenas as observações nos nossos municípios de interesse\n\n2\n\nComputa temporariamente o resultado\n\n3\n\nAgrupa as observações por área de ponderação\n\n4\n\nCalcula o valor médio do aluguel\n\n5\n\nColeta os resultados.\n\n\n\n\n# A tibble: 6 × 2\n  code_weighting avgrent\n  &lt;chr&gt;            &lt;dbl&gt;\n1 3503901003001     355.\n2 3503901003002     627.\n3 3503901003003     358.\n4 3505708005001     577.\n5 3505708005002     397.\n6 3505708005003     327.\n\n\nPor fim, basta unirmos os dados espaciais com nossas estimativas de aluguel pela variável chave de código da área de ponderação (code_weighting), e mapear os resultados.\n\nrent_sf &lt;- left_join(wt_areas, rent, by = 'code_weighting')\n\nggplot() +\n  geom_sf(data = rent_sf, aes(fill = avgrent), color=NA) +\n  geom_sf(data = metro_sp, color='gray', fill=NA) +\n  labs(title = \"Valor médio do aluguel por área de ponderação\",\n       subtitle = \"Região Metropolitana de São Paulo, 2010\") +\n  scale_fill_distiller(palette = \"Purples\", direction = 1, \n                       name='Valores\\nem R$',\n                       labels = scales::number_format(big.mark = \".\")) +\n  theme_void()",
    "crumbs": [
      "Explorando o Censo Demográfico",
      "Microdados do Censo"
    ]
  },
  {
    "objectID": "11_censobr_microdados.html#data-cache",
    "href": "11_censobr_microdados.html#data-cache",
    "title": "Microdados do Censo",
    "section": "Data cache",
    "text": "Data cache\nNa primeira vez que o usuário executa uma função, o {censobr} fará o download do arquivo e o armazenará localmente. Dessa forma, os dados só precisam ser baixados uma vez. Quando o parâmetro cache está configurado como TRUE (que é o comportamento padrão do pacote), a função lerá os dados que já estão armanezados em cache, o que é praticamente instantâneo.\nOs usuários podem gerenciar os conjuntos de dados em cache usando a função censobr_cache(). Por exemplo, os usuários podem:\nListar arquivos em cache:\n\ncensobr_cache(list_files = TRUE)\n\nDeletar um arquivo específico:\n\ncensobr_cache(delete_file = \"2010_emigration\")\n\nDeletar todos arquivos do cache:\n\ncensobr_cache(delete_file = \"all\")\n\nPor padrão, os arquivos do {censobr} são salvos no diretório ‘User’. No entanto, os usuários podem executar a função set_censobr_cache_dir() para definir um diretório de cache personalizado. Note que essa definição personalizada precisa ser definida a cada nova sessão do R.\n\ntempf &lt;- tempdir()\n\nset_censobr_cache_dir(path = tempf)",
    "crumbs": [
      "Explorando o Censo Demográfico",
      "Microdados do Censo"
    ]
  },
  {
    "objectID": "03_importacao.html",
    "href": "03_importacao.html",
    "title": "Importando dados",
    "section": "",
    "text": "Conceitos prévios importantes:\n\nPacotes, funções e objetos no R\nProjetos do RStudio (.Rproj) e diretórios de trabalho\nCaminhos de arquivos\nO objetivo da etapa de importação é carregar a base de dados para a memória RAM do computador. Assim conseguiremos utilizar os dados no R.\nEssa etapa pode ser bem rápida (ou não!). Depende da base de dados que precisamos carregar.\nNesta etapa, vamos aprender:\nAo final, teremos também uma lista com sugestão de materiais extras, caso queira aprofundar mais sobre o assunto.",
    "crumbs": [
      "Materiais",
      "Importando dados"
    ]
  },
  {
    "objectID": "03_importacao.html#importando-dados-de-um-arquivo-local",
    "href": "03_importacao.html#importando-dados-de-um-arquivo-local",
    "title": "Importando dados",
    "section": "Importando dados de um arquivo local",
    "text": "Importando dados de um arquivo local\nPara importar dados de um arquivo local, você pode usar funções com o prefixo read_ de pacotes como readr e readxl.\nArquivos de texto (ex: .csv)\nO pacote readr permite a leitura de arquivos de texto separados por algum delimitador, como .csv, .tsv e .txt.\n\nlibrary(readr)\n\nPara realizar a importação de um arquivo deste tipo, é importante saber qual é o delimitador utilizado no arquivo.\nA sigla CSV signfica Comma Separated Values, ou seja, valores separados por vírgula. Por padrão, a função read_csv() do pacote readr importa arquivos .csv com delimitador ,.\nNo Brasil, é comum a utilização do ; como delimitador, e para isso podemos utilizar a função read_csv2(). Isso acontece pois utilizamos a vírgula como separador decimal (Ex: 4,20) e isso pode causar problemas na importação de arquivos .csv com delimitador ,.\nCaso o arquivo tenha outro delimitador, você pode utilizar a função read_delim() e especificar o delimitador com o argumento delim.\nAo importar, uma mensagem aparecerá no console apresentando algumas informações sobre a importação, como:\n\nnúmero de linhas;\nnúmero de colunas;\ndelimitador utilizado;\ntipos de colunas;\nnome das colunas por tipo;\nquantidade de colunas importadas por tipo.\n\n\n\nCaptura de tela do console do RStudio, mostrando a mensagem apresentada pela função read_csv()\n\nArquivo de texto separado por vírgula (,)\n\n# Importando dados de um arquivo .csv\ndados_csv &lt;- read_csv(\"dados/sidrar_4092.csv\")\n\nRows: 1350 Columns: 13\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (2): trimestre_texto, unidade_da_federacao\ndbl  (9): ano, trimestre_numero, trimestre_codigo, unidade_da_federacao_codi...\ndate (2): trimestre_data_inicio, trimestre_data_fim\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nArquivo de texto separado por ponto e vírgula (;)\n\n# Importando dados de um arquivo .csv\n# Com separador ponto e vírgula\ndados_csv_2 &lt;- read_csv2(\"dados/sidrar_4092_2.csv\")\n\nℹ Using \"','\" as decimal and \"'.'\" as grouping mark. Use `read_delim()` for more control.\n\n\nRows: 1350 Columns: 13\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \";\"\nchr  (2): trimestre_texto, unidade_da_federacao\ndbl  (9): ano, trimestre_numero, trimestre_codigo, unidade_da_federacao_codi...\ndate (2): trimestre_data_inicio, trimestre_data_fim\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nArquivos Excel (ex: .xlsx)\nO pacote readxl permite a leitura de arquivos do Excel.\n\n# Carregando o pacote readxl\nlibrary(readxl)\n\nA função excel_sheets() do pacote readxl retorna o nome das planilhas (Sheets) disponíveis em um arquivo Excel:\n\nexcel_sheets(\"dados/sidrar_4092.xlsx\")\n\n[1] \"Sheet1\"\n\n\nA função read_excel() do pacote readxl permite a leitura de uma planilha específica de um arquivo Excel, utilizando o argumento sheet para especificar o nome da planilha. Caso o argumento sheet não seja fornecido, a função importará a primeira planilha do arquivo.\n\n# Importando dados de uma planilha do Excel\ndados_excel &lt;- read_excel(\"dados/sidrar_4092.xlsx\", sheet = \"Sheet1\")\n\nArquivo binário do R (.rds)\nA função read_rds() do pacote readr permite importar um arquivo binário do R.\n\ndados &lt;- read_rds(\"dados/sidrar_4092.rds\")\n\nImport Dataset do RStudio\nCaso você esteja com dificuldades, uma dica é usar a funcionalidade Import Dataset do RStudio. Essa funcionalidade permite utilizar uma interface point-and-click para importar dados, e apresenta o código utilizado para a importação.\n\n\n\n\n\n\nDica\n\n\n\nO mais importante ao usar essa funcionalidade é copiar e colar o código gerado no seu script, para que você possa reutilizá-lo posteriormente.\n\n\nPara acessar a funcionalidade Import Dataset, clique em Import Dataset no canto superior direito do painel Environment do RStudio. Caso o arquivo seja um Excel, escolha a opção From Excel. Caso o arquivo seja um texto separado por algum delimitador (como CSV), escolha a opção From Text (readr).\n\n\nCaptura de tela do console do RStudio, mostrando o menu onde podemos encontrar o Import Dataset",
    "crumbs": [
      "Materiais",
      "Importando dados"
    ]
  },
  {
    "objectID": "03_importacao.html#salvando-dados-localmente",
    "href": "03_importacao.html#salvando-dados-localmente",
    "title": "Importando dados",
    "section": "Salvando dados localmente",
    "text": "Salvando dados localmente\nPara salvar dados localmente, você pode usar funções com o prefixo write_ de pacotes como readr e writexl. Essas funções solicitam dois argumentos principais:\n\nQual é o objeto que você queremos salvar? Esse objeto deve estar disponível no Environment do R.\nOnde queremos salvar o arquivo? O caminho completo do arquivo deve ser fornecido entre aspas, contendo o diretório onde ele será salvo (em qual pasta do computador) e o nome do arquivo (com a extensão, por exemplo, .csv).\n\nAntes de salvar os dados, vamos criar um diretório onde salvaremos os arquivos. Você pode criar o diretório manualmente ou usar a função fs::dir_create(\"nome_do_diretorio/\") para criar o diretório.\n\nlibrary(fs)\ndir_create(\"dados_output\")\n\n\n\n\n\n\n\nAviso\n\n\n\nAtenção: O diretório (pasta no computador) onde o arquivo será salvo deve existir previamente, se não gerará um erro similar a este:\nError: Cannot open file for writing:\n* 'dados_output/sidrar_4092_salvo.csv'\n\n\nArquivo de texto (ex: .csv)\nO pacote readr permite a escrita de arquivos de texto separados por algum delimitador, como .csv, .tsv e .txt.\nA função write_csv2() premite a escrita de arquivos .csv com separador ;, que é o padrão no Brasil.\n\nwrite_csv2(dados, \"dados_output/sidrar_4092.csv\")\n\nArquivo excel (ex: .xlsx)\nA função write_xlsx() do pacote writexl permite a escrita de arquivos do Excel.\n\nlibrary(writexl)\nwrite_xlsx(dados, \"dados_output/sidrar_4092.csv\")\n\nArquivo binário do R (.rds)\nA função write_rds() do pacote readr permite salvar um objeto do R em um arquivo binário do R, preservando a estrutura dos objetos.\nEsse tipo de arquivo é útil para salvar objetos do R, como dataframes, listas, vetores, sem perder a estrutura do objeto.\n\nwrite_rds(dados, \"dados_output/sidrar_4092.rds\")",
    "crumbs": [
      "Materiais",
      "Importando dados"
    ]
  },
  {
    "objectID": "03_importacao.html#importando-dados-usando-pacotes-de-dados",
    "href": "03_importacao.html#importando-dados-usando-pacotes-de-dados",
    "title": "Importando dados",
    "section": "Importando dados usando pacotes de dados",
    "text": "Importando dados usando pacotes de dados\nExistem pacotes no R que permitem a importação de dados, como por exemplo: sidrar, geobr, censobr, entre outros.\nA parte boa de usar esses pacotes é que eles já possuem funções prontas para importar os dados.\nA parte não-tão-boa é que os pacotes tem funções específicas para importar os dados, e você precisa aprender como usar essas funções. Recomendamos que você leia a documentação do pacote para entender como usar as funções de importação.\nAo longo deste curso, vamos aprender a usar alguns desses pacotes para importar dados específicos.\n\n\n\n\n\n\nImportante\n\n\n\nEsses pacotes, em geral, obtém as informações na internet. Isso pode demorar um pouco.\nRecomendamos que você salve uma cópia local dos dados brutos após o download. Isso evita a necessidade de baixar os dados novamente e facilita o trabalho localmente, principalmente se a conexão com a internet estiver instável.\nAlguns pacotes, como o censobr, apresentam funções preparadas para salvar os dados localmente.\n\n\nPacote {sidrar}\n\nO pacote sidrar permite a importação de dados do Sistema IBGE de Recuperação Automática (SIDRA).\n\nlibrary(sidrar)\n\nPara importar dados do SIDRA, você precisa saber o código da tabela que deseja importar. Uma forma de fazer isso é buscar no site do SIDRA, no IBGE: https://sidra.ibge.gov.br/.\nBuscando tabelas no SIDRA\nOutra forma é buscar por palavras-chave no próprio R, utilizando a função search_sidra():\n\n# Exemplo de busca por palavras-chave: \n# Tabelas com resultados da PNAD Contínua Trimestral\nsearch_sidra(\"PNADCT\")\n\n [1] \"Tabela 5435 - Pessoas de 14 anos ou mais de idade, ocupadas na semana de referência, por grupamento ocupacional no trabalho principal\"                                                                                                                                                             \n [2] \"Tabela 5444 - Rendimento médio mensal real das pessoas de 14 anos ou mais de idade ocupadas na semana de referência com rendimento de trabalho, habitualmente e efetivamente recebidos no trabalho principal, por grupamento ocupacional no trabalho principal\"                                    \n [3] \"Tabela 9440 - Pessoas de 14 anos ou mais de idade ocupadas na semana de referência, exclusive os empregados no setor público e militares, por grupamento ocupacional no trabalho principal e trabalho por meio de plataforma digital de serviço no trabalho principal - Estatísticas experimentais\"\n [4] \"Tabela 9457 - Indicador 8.5.1 - Rendimento médio por hora real das pessoas de 15 anos ou mais de idade ocupadas na semana de referência com rendimento de trabalho, habitualmente recebido em todos os trabalhos, por grupamento ocupacional no trabalho principal\"                                \n [5] \"Tabela 9485 - Percentual de pessoas de 14 anos ou mais de idade ocupadas na semana de referência, exclusive os empregados no setor público e militares, que trabalharam por meio de plataformas de serviços, por grupamento ocupacional no trabalho principal - Estatísticas experimentais\"        \n [6] \"Tabela 9540 - Percentual de pessoas de 14 anos ou mais de idade ocupadas na semana de referência que realizaram teletrabalho no período de referência de 30 dias, por grupamento ocupacional no trabalho principal - Estatísticas experimentais\"                                                   \n [7] \"Tabela 9572 - Percentual de pessoas de 14 anos ou mais de idade ocupadas na semana de referência que realizaram teletrabalho no domicílio no período de referência de 30 dias, por grupamento ocupacional no trabalho principal - Estatísticas experimentais\"                                      \n [8] \"Tabela 9575 - Pessoas de 14 anos ou mais de idade ocupadas na semana de referência que trabalharam no domicílio, por grupamento ocupacional no trabalho principal e frequência do trabalho no domicílio - Estatísticas experimentais\"                                                              \n [9] \"Tabela 9599 - Pessoas de 14 anos ou mais de idade ocupadas na semana de referência, por grupamento ocupacional no trabalho principal e realização de teletrabalho fora do domicílio no período de referência de 30 dias - Estatísticas experimentais\"                                              \n[10] \"Tabela 9603 - Percentual de pessoas de 14 anos ou mais de idade ocupadas na semana de referência que realizaram teletrabalho fora do domicílio no período de referência de 30 dias, por grupamento ocupacional no trabalho principal - Estatísticas experimentais\"                                 \n[11] \"Tabela 9617 - Pessoas de 14 anos ou mais de idade ocupadas na semana de referência, por grupamento ocupacional no trabalho principal e realização de teletrabalho no período de referência de 30 dias - Estatísticas experimentais\"                                                                \n[12] \"Tabela 9624 - Pessoas de 14 anos ou mais de idade ocupadas na semana de referência, por grupamento ocupacional no trabalho principal e realização de teletrabalho no domicílio no período de referência de 30 dias - Estatísticas experimentais\"                                                   \n\n\nNeste curso, utilizaremos na maioria das aulas a Tabela 4092 - Pessoas de 14 anos ou mais de idade, por condição em relação à força de trabalho e condição e ocupação, proveniente da Pesquisa Nacional por Amostra de Domicílios Contínua Trimestral (PNADC/T).\nBuscando informações sobre a tabela\nSabendo o código da tabela, você pode buscar informações sobre a tabela com a função info_sidra().\n\ninfo_4092 &lt;- info_sidra(\"4092\")\n\nO resultado dessa função é uma lista, portanto podemos acessar os elementos da lista utilizando o operador $, seguido pelo nome do elemento.\nPrimeiro, podemos ver os nomes dos elementos da lista:\n\nnames(info_4092)\n\n[1] \"table\"              \"period\"             \"variable\"          \n[4] \"classific_category\" \"geo\"               \n\n\nAgora podemos consultar os elementos dessa lista!\nNome da tabela\n\ninfo_4092$table\n\n[1] \"Tabela 4092: Pessoas de 14 anos ou mais de idade, por condição em relação à força de trabalho e condição de ocupação\"\n\n\nPeríodos\nIsso será importante para a importação dos dados, pois podemos informar qual período queremos importar.\n\ninfo_4092$period\n\n[1] \"201201, 201202, 201203, 201204, 201301, 201302, 201303, 201304, 201401, 201402, 201403, 201404, 201501, 201502, 201503, 201504, 201601, 201602, 201603, 201604, 201701, 201702, 201703, 201704, 201801, 201802, 201803, 201804, 201901, 201902, 201903, 201904, 202001, 202002, 202003, 202004, 202101, 202102, 202103, 202104, 202201, 202202, 202203, 202204, 202301, 202302, 202303, 202304, 202401, 202402\"\n\n\nEsses dados estão salvos em um vetor de tamanho um, com textos separados por vírgula. Esse formato não é o ideal para usar na função de importação que veremos a seguir: o melhor é transformar em um vetor, onde cada elemento é um período.\nPodemos fazer isso com a função str_split():\n\nperiodos_disponiveis &lt;- stringr::str_split(info_4092$period, \", \")[[1]]\nperiodos_disponiveis\n\n [1] \"201201\" \"201202\" \"201203\" \"201204\" \"201301\" \"201302\" \"201303\" \"201304\"\n [9] \"201401\" \"201402\" \"201403\" \"201404\" \"201501\" \"201502\" \"201503\" \"201504\"\n[17] \"201601\" \"201602\" \"201603\" \"201604\" \"201701\" \"201702\" \"201703\" \"201704\"\n[25] \"201801\" \"201802\" \"201803\" \"201804\" \"201901\" \"201902\" \"201903\" \"201904\"\n[33] \"202001\" \"202002\" \"202003\" \"202004\" \"202101\" \"202102\" \"202103\" \"202104\"\n[41] \"202201\" \"202202\" \"202203\" \"202204\" \"202301\" \"202302\" \"202303\" \"202304\"\n[49] \"202401\" \"202402\"\n\n\nEsses são os períodos disponíveis para essa tabela no SIDRA.\nVariáveis\nIsso será importante para a importação dos dados, pois podemos informar quais variáveis queremos importar.\n\ninfo_4092$variable\n\n   cod\n1 1641\n2 4087\n3 4104\n4 4105\n                                                                                         desc\n1                                             Pessoas de  anos ou mais de idade (Mil pessoas)\n2                             Coeficiente de variação - Pessoas de  anos ou mais de idade (%)\n3                           Distribuição percentual das pessoas de  anos ou mais de idade (%)\n4 Coeficiente de variação - Distribuição percentual das pessoas de  anos ou mais de idade (%)\n\n\nVariáveis - Categorias\n\ninfo_4092$classific_category\n\n$`c629 = Condição em relação à força de trabalho e condição de ocupação (5):`\n    cod                           desc\n1 32385                          Total\n2 32386              Força de trabalho\n3 32387    Força de trabalho - ocupada\n4 32446 Força de trabalho - desocupada\n5 32447      Fora da força de trabalho\n\n\nNível territorial\nIsso será importante para a importação dos dados, pois precisamos informar qual é o nível territorial a ser usado na importação.\n\ninfo_4092$geo\n\n          cod\n1      Brazil\n2         IRD\n3      Region\n4       State\n5        City\n6 MetroRegion\n                                                                                                                 desc\n1                                                                                                          Brasil (1)\n2 Região Integrada de Desenvolvimento  [1º trimestre 2012 a 1º trimestre 2020, 2º trimestre 2022 a 2º trimestre 2024]\n3                                                                                                   Grande Região (5)\n4                                                                                           Unidade da Federação (27)\n5                           Município  [1º trimestre 2012 a 1º trimestre 2020, 2º trimestre 2022 a 2º trimestre 2024]\n6                Região Metropolitana  [1º trimestre 2012 a 1º trimestre 2020, 2º trimestre 2022 a 2º trimestre 2024]\n\n\nImportando a tabela\nA função get_sidra() do pacote sidrar permite importar dados do SIDRA.\n\ndados_brutos_4092 &lt;- sidrar::get_sidra(\n  x = 4092,\n  period = periodos_disponiveis,\n  geo = \"State\"\n)\n\n\n1\n\nQual é o código da tabela que vamos usar?\n\n2\n\nPeríodos: trimestres, vamos usar o vetor criado anteriormente\n\n3\n\nNível territorial: Dados por UF\n\n\n\n\nLembrando que é importante salvar uma cópia local dos dados após o download. Assim, quando você for trabalhar com esses dados, não precisará baixá-los novamente.\n\n# Salvar localmente essa base de dados\nwrite_rds(dados_brutos_4092, \"dados/sidrar_4092_bruto.rds\")\n\n\n# Importando os dados salvos localmente\ndados_brutos_4092 &lt;- read_rds(\"dados/sidrar_4092_bruto.rds\")",
    "crumbs": [
      "Materiais",
      "Importando dados"
    ]
  },
  {
    "objectID": "03_importacao.html#sugestões-de-materiais",
    "href": "03_importacao.html#sugestões-de-materiais",
    "title": "Importando dados",
    "section": "Sugestões de materiais",
    "text": "Sugestões de materiais\n\nLivro R para Ciência de Dados 2ed:\n\nImportação de dados\n\n\nVídeo Como organizar seu banco de dados para análises estatísticas, por Fernanda Peres (30 minutos).",
    "crumbs": [
      "Materiais",
      "Importando dados"
    ]
  },
  {
    "objectID": "00_projeto_eda.html",
    "href": "00_projeto_eda.html",
    "title": "Projeto de Análise Exploratória de Dados com R",
    "section": "",
    "text": "Com o objetivo de praticar os conceitos apresentados no curso, recomendamos que as pessoas participantes realizem um projeto de análise exploratória de dados paralelamente às aulas. Este projeto permitirá que você consolide o aprendizado adquirido, explorando dados reais e aplicando as ferramentas de análise discutidas em aula.\nAproveite o projeto para aplicar os conceitos apresentados no curso e para explorar novas funcionalidades do R. Ao se deparar com uma dúvida, não esqueça de anotar e perguntar durante as aulas para os monitores. A equipe do curso está disponível para auxiliar com dúvidas sobre o projeto até a data final do curso.\nOs passos a seguir podem te ajudar a organizar o projeto de análise exploratória de dados:\n\nEscolha um conjunto de dados: Você pode escolher um conjunto de dados de sua preferência. Caso não tenha um conjunto de dados em mente, sugerimos que escolha um dos conjuntos de dados disponíveis nos seguintes pacotes:\n\nsidrar: Acesso aos dados disponíveis no SIDRA - Sistema IBGE de Recuperação Automática.\ncensobr: Dados de censos demográficos brasileiros.\nipeadatar: Acesso aos dados disponibilizados no Ipeadata.\nflightsbr: Dados de vôos no Brasil.\nPNADcIBGE: Dados da PNAD Contínua do IBGE.\n\nCrie um projeto no RStudio: Crie um projeto no RStudio para armazenar os códigos e arquivos do projeto. Esse procedimento será descrito na aula Conhecendo o R e o RStudio.\nImporte os dados: Importe o conjunto de dados escolhido para o R. Esse procedimento será descrito na aula Importando dados.\nObjetivo da análise: Defina o objetivo da análise exploratória de dados. Quais são as perguntas que você deseja responder a partir desta base de dados?\nDescreva o conjunto de dados brutos: Faça uma breve descrição do conjunto de dados escolhido. Qual é a unidade amostral (o que cada linha significa)? Quais são as variáveis presentes? Quais são os tipos de variáveis? Você pode incluir tabelas ou gráficos para facilitar a visualização das variáveis e sua distribuição. O que precisa ser feito para deixar a tabela “limpa”, ou seja, pronta para a análise?\nLimpeza dos dados: Utilize o que você aprendeu na etapa passada para limpar o conjunto de dados. Isso pode incluir lidar com dados ausentes, remover outliers ou inconsistências. A aula Transformando dados será útil nessa etapa.\nRealize a análise exploratória de dados: Utilize os conceitos apresentados no curso para realizar a análise exploratória de dados do conjunto escolhido. Lembre-se do objetivo que você definiu anteriormente e busque responder às perguntas que você levantou. Inclua gráficos e tabelas para apresentar os resultados e escreva suas interpretações ao longo do processo. As aulas Analisando dados e Visualizando dados serão úteis nessa etapa.\nPróximos passos: Você pode apresentar os resultados para outras pessoas envolvidas no curso (participantes, ministrantes, monitores) e solicitar feedbacks.",
    "crumbs": [
      "Pré-curso",
      "Projeto de Análise Exploratória de Dados com R"
    ]
  },
  {
    "objectID": "13_censobr_documentacao.html",
    "href": "13_censobr_documentacao.html",
    "title": "Documentação dos Censos",
    "section": "",
    "text": "Além de funções para leitura dos dados, o pacote {censobr} traz ainda um conjunto de funções que permitem rápido acesso à documentação dos censos demográficos, incluindo os dicionários de variáveis, questionários e manual do entrevistador para entrevistas.\nTabela 2. Funções de documentação disponíveis no {censobr}\n\n\n\n    \n\n\n\n\n\nFunção\nDocumentação\nTipo\nDisponibilidade\n\n\n1960\n70\n80\n91\n2000\n10\n22\n\n\n\n\ndata_dictionary()\nDicionário de variáveis\nMicrodados\nX\nX\nX\nX\nX\nX\nem breve\n\n\nAgregados de setores censitários\n\n\n\n\nX\nX\nem breve\n\n\nquestionnaire()\nQuestionários\nLongo e curto\nX\nX\nX\nX\nX\nX\nX\n\n\ninterview_manual()\nManual do entrevistador\n-\nX\nX\nX\nX\nX\nX\nX\n\n\n\nTodas funções de documentação baixam os arquivos em formato .html ou .pdf, e abrem o documento no navegador (browser). Assim como as funções de leitura de dados do {censobr}, essas funções de documentação também salvam os arquivos num cache local na primeira vez que a função é rodada. Assim, quando o usuário roda a função novamente, o pacote simplesmente carrega o arquivo local de maneira quase instantânea.\n\nA função data_dictionary() carrega o dicionário de variáveis, apontando a definição de cada variável e o significado de suas categorias no caso de variáveis categóricas. Atualmente, a função abrange os dicionários dos microdados da amostra para todos os censos brasileiros desde 1960: c(1960, 1970, 1980, 1991, 2000 e 2010). Além disso, a função também inclui atualmente os dicionários dos dados do universo agregados em setores censitário para os anos 2000 e 2010.\n\nlibrary(censobr)\n\n# dicionário de variáveis de pessoas (microdados da amostra)\ndata_dictionary(year = 2010, \n                dataset = 'population')\n\n# dicionário de variáveis de domicílios (microdados da amostra)\ndata_dictionary(year = 2010, \n                dataset = 'households')\n\n\n# dicionário de variáveis de setores censitários (agregados do universo)\ndata_dictionary(year = 2010, \n                dataset = 'tracts')\n\n\nCom frequência, é importante se entender a estrutura e fluxo do questionário utilizado em pesquisas de coleta de dados. A função questionnaire() inclui os questionários utilizados na coleta de dados de todos os censos brasileiros desde 1960.\nAlém de passar o parâmetro year, o usuário precisa indicar o tipo de questionário de interesse, se o questionário curto do universo (type = 'short') ou o questionário longo utilizado na pesquisa amostral (type = 'long').\n\n# questionário curto da pesquisa do universo\nquestionnaire(year = 2022, \n              type = 'short')\n\n# questionário longo da pesquisa amostral\nquestionnaire(year = 2022, \n              type = 'long')\n\n\nPor fim, a função interview_manual() faz o download e abre no navegador o “Manual do Recenseador”, ou seja, o manual de instruções para os recenseadores do IBGE sobre como coletar os dados do censo. Estão disponíveis os manuais de todos os censos desde 1960.\n\n# Censo de 2010\ninterview_manual(year = 2022)\n\n# Censo de 1970\ninterview_manual(year = 1960)",
    "crumbs": [
      "Explorando o Censo Demográfico",
      "Documentação dos Censos"
    ]
  },
  {
    "objectID": "13_censobr_documentacao.html#documentação-do-censo-disponível-no-censobr",
    "href": "13_censobr_documentacao.html#documentação-do-censo-disponível-no-censobr",
    "title": "Documentação dos Censos",
    "section": "",
    "text": "Além de funções para leitura dos dados, o pacote {censobr} traz ainda um conjunto de funções que permitem rápido acesso à documentação dos censos demográficos, incluindo os dicionários de variáveis, questionários e manual do entrevistador para entrevistas.\nTabela 2. Funções de documentação disponíveis no {censobr}\n\n\n\n    \n\n\n\n\n\nFunção\nDocumentação\nTipo\nDisponibilidade\n\n\n1960\n70\n80\n91\n2000\n10\n22\n\n\n\n\ndata_dictionary()\nDicionário de variáveis\nMicrodados\nX\nX\nX\nX\nX\nX\nem breve\n\n\nAgregados de setores censitários\n\n\n\n\nX\nX\nem breve\n\n\nquestionnaire()\nQuestionários\nLongo e curto\nX\nX\nX\nX\nX\nX\nX\n\n\ninterview_manual()\nManual do entrevistador\n-\nX\nX\nX\nX\nX\nX\nX\n\n\n\nTodas funções de documentação baixam os arquivos em formato .html ou .pdf, e abrem o documento no navegador (browser). Assim como as funções de leitura de dados do {censobr}, essas funções de documentação também salvam os arquivos num cache local na primeira vez que a função é rodada. Assim, quando o usuário roda a função novamente, o pacote simplesmente carrega o arquivo local de maneira quase instantânea.",
    "crumbs": [
      "Explorando o Censo Demográfico",
      "Documentação dos Censos"
    ]
  },
  {
    "objectID": "13_censobr_documentacao.html#dicionário-de-dados",
    "href": "13_censobr_documentacao.html#dicionário-de-dados",
    "title": "Documentação dos Censos",
    "section": "",
    "text": "A função data_dictionary() carrega o dicionário de variáveis, apontando a definição de cada variável e o significado de suas categorias no caso de variáveis categóricas. Atualmente, a função abrange os dicionários dos microdados da amostra para todos os censos brasileiros desde 1960: c(1960, 1970, 1980, 1991, 2000 e 2010). Além disso, a função também inclui atualmente os dicionários dos dados do universo agregados em setores censitário para os anos 2000 e 2010.\n\nlibrary(censobr)\n\n# dicionário de variáveis de pessoas (microdados da amostra)\ndata_dictionary(year = 2010, \n                dataset = 'population')\n\n# dicionário de variáveis de domicílios (microdados da amostra)\ndata_dictionary(year = 2010, \n                dataset = 'households')\n\n\n# dicionário de variáveis de setores censitários (agregados do universo)\ndata_dictionary(year = 2010, \n                dataset = 'tracts')",
    "crumbs": [
      "Explorando o Censo Demográfico",
      "Documentação dos Censos"
    ]
  },
  {
    "objectID": "13_censobr_documentacao.html#questionários",
    "href": "13_censobr_documentacao.html#questionários",
    "title": "Documentação dos Censos",
    "section": "",
    "text": "Com frequência, é importante se entender a estrutura e fluxo do questionário utilizado em pesquisas de coleta de dados. A função questionnaire() inclui os questionários utilizados na coleta de dados de todos os censos brasileiros desde 1960.\nAlém de passar o parâmetro year, o usuário precisa indicar o tipo de questionário de interesse, se o questionário curto do universo (type = 'short') ou o questionário longo utilizado na pesquisa amostral (type = 'long').\n\n# questionário curto da pesquisa do universo\nquestionnaire(year = 2022, \n              type = 'short')\n\n# questionário longo da pesquisa amostral\nquestionnaire(year = 2022, \n              type = 'long')",
    "crumbs": [
      "Explorando o Censo Demográfico",
      "Documentação dos Censos"
    ]
  },
  {
    "objectID": "13_censobr_documentacao.html#manual-do-entrevistador",
    "href": "13_censobr_documentacao.html#manual-do-entrevistador",
    "title": "Documentação dos Censos",
    "section": "",
    "text": "Por fim, a função interview_manual() faz o download e abre no navegador o “Manual do Recenseador”, ou seja, o manual de instruções para os recenseadores do IBGE sobre como coletar os dados do censo. Estão disponíveis os manuais de todos os censos desde 1960.\n\n# Censo de 2010\ninterview_manual(year = 2022)\n\n# Censo de 1970\ninterview_manual(year = 1960)",
    "crumbs": [
      "Explorando o Censo Demográfico",
      "Documentação dos Censos"
    ]
  },
  {
    "objectID": "index.html#introdução-ao-material",
    "href": "index.html#introdução-ao-material",
    "title": "Introdução à análise de dados no R",
    "section": "Introdução ao material",
    "text": "Introdução ao material\nEste site apresenta o material de apoio para o curso “Introdução à análise de dados no R”, oferecido em 2024 para servidores do Instituto de Pesquisa Econômica Aplicada (Ipea). O curso será realizado de forma remota híbrida, com aulas ao vivo e atividades práticas.\n\n\n\n\n\n\nImportante\n\n\n\nRecomendamos que todas as pessoas participantes instalem o R e o RStudio antes do início do curso. Para isso, siga as instruções disponíveis na página Instruções de instalação.\nCaso tenha alguma dificuldade, entre em contato com a equipe do curso o quanto antes.",
    "crumbs": [
      "Pré-curso",
      "Introdução à análise de dados no R"
    ]
  },
  {
    "objectID": "index.html#equipe-do-curso",
    "href": "index.html#equipe-do-curso",
    "title": "Introdução à análise de dados no R",
    "section": "Equipe do curso",
    "text": "Equipe do curso\nBeatriz Milz  Pesquisadora Colaboradora | Estágio pós-doutoral  Laboratório de Planejamento Territorial (LaPlan) - Universidade Federal do ABC (UFABC)  Email | GitHub | LinkedIn | ResearchGate | Currículo Lattes | Orcid\nPedro Cavalcanti Gonçalves Ferreira  Coordenação de Ciência de Dados - COCD  Instituto de Pesquisa Econômica Aplicada (Ipea)  GitHub | LinkedIn | Currículo Lattes | Orcid\nRafael H. M. Pereira  Coordenador de Ciência de Dados  Instituto de Pesquisa Econômica Aplicada (Ipea)  Website | Google Scholar | Linkedin |",
    "crumbs": [
      "Pré-curso",
      "Introdução à análise de dados no R"
    ]
  },
  {
    "objectID": "index.html#sobre-este-material",
    "href": "index.html#sobre-este-material",
    "title": "Introdução à análise de dados no R",
    "section": "Sobre este material",
    "text": "Sobre este material\nEsse material está disponível sob a licença CC BY-SA 4.0.",
    "crumbs": [
      "Pré-curso",
      "Introdução à análise de dados no R"
    ]
  },
  {
    "objectID": "07_analise.html",
    "href": "07_analise.html",
    "title": "Analisando dados",
    "section": "",
    "text": "Aviso\n\n\n\nPágina em construção! Em breve.",
    "crumbs": [
      "Materiais",
      "Analisando dados"
    ]
  },
  {
    "objectID": "07_analise.html#sugestões-de-materiais",
    "href": "07_analise.html#sugestões-de-materiais",
    "title": "Analisando dados",
    "section": "Sugestões de materiais",
    "text": "Sugestões de materiais\n\nLivro Metodologia de Pesquisa Jurimétrica:\n\nCapítulo 3 - Estatísticas",
    "crumbs": [
      "Materiais",
      "Analisando dados"
    ]
  },
  {
    "objectID": "10_censobr_conceitos.html",
    "href": "10_censobr_conceitos.html",
    "title": "Conceitos iniciais do Censo",
    "section": "",
    "text": "O censo demográfico brasileiro é a principal pesquisa populacional domiciliar realizada no Brasil, conduzida pelo Instituto Brasileiro de Geografia e Estatística (IBGE). Trata-se da pesquisa de maior cobertura territorial do país, e que levanta informações sobre as características e condições de vida da população brasileira nos mais diversos temas, como perfil demográfico, educação, trabalho, fecundidade, migração, condições de moradia, etc.\nNesta seção, nós revisamos alguns conceitos básicos sobre a organização dos censos demográficos no Brasil.",
    "crumbs": [
      "Explorando o Censo Demográfico",
      "Conceitos iniciais do Censo"
    ]
  },
  {
    "objectID": "10_censobr_conceitos.html#pesquisa-da-amostra-e-do-universo",
    "href": "10_censobr_conceitos.html#pesquisa-da-amostra-e-do-universo",
    "title": "Conceitos iniciais do Censo",
    "section": "Pesquisa da amostra e do universo",
    "text": "Pesquisa da amostra e do universo\nDesde 1960, o Censo Demográfico passou a consistir de duas pesquisas realizadas simultaneamente.\n\n\nUniverso: uma pesquisa aplicada a todos os domicílios (ou universo). Esta pesquisa é feita com um questionário básico que costuma ser curto, contendo entre 9 e 30 questões, dependendo da edição do censo.\n\nAmostra: uma pesquisa amostral aplicada a apenas uma parcela dos domicílios. A fração amostral era de 25% nos anos de 1960, 1970 e 1980 e passou para cerca de 10% em 1991 em diante. Esta pesquisa é feita com um questionário mais extenso.",
    "crumbs": [
      "Explorando o Censo Demográfico",
      "Conceitos iniciais do Censo"
    ]
  },
  {
    "objectID": "10_censobr_conceitos.html#microdados-da-amostra-e-dados-agregados-do-universo",
    "href": "10_censobr_conceitos.html#microdados-da-amostra-e-dados-agregados-do-universo",
    "title": "Conceitos iniciais do Censo",
    "section": "Microdados da Amostra e Dados Agregados do Universo",
    "text": "Microdados da Amostra e Dados Agregados do Universo\nMicrodados são bancos de dados em que cada observação representa uma unidade de coleta de informação. Nos censos, os microdados se referem aos arquivos em que cada observação ou linha são domicílios ou pessoas. A noção de microdados se contrapõe à de dados agregados, nos quais os casos são “agregações” das informações obtidas a partir por exemplo da soma ou das médias das informações dos microdados. Tais agregações podem ser, por exemplo, no nível de bairros, distritos, municípios etc.\n\n\n\n\n\n\nImportante\n\n\n\nOs dados disponibilizados pelo IBGE, e que estão disponíveis no pacote {censobr} incluem tnato os microdados da pesquisa amostral quanto os dados do universo agregados por setor censitário.\nObs. O IBGE não disponibiliza os microdados do universo porque a sua divulgação poderia violar o sigilo dos respondentes.",
    "crumbs": [
      "Explorando o Censo Demográfico",
      "Conceitos iniciais do Censo"
    ]
  },
  {
    "objectID": "10_censobr_conceitos.html#setores-censitários-e-áreas-de-ponderação",
    "href": "10_censobr_conceitos.html#setores-censitários-e-áreas-de-ponderação",
    "title": "Conceitos iniciais do Censo",
    "section": "Setores Censitários e Áreas de Ponderação",
    "text": "Setores Censitários e Áreas de Ponderação\nCom os Microdados da Amostra é possível fazer análises por indivíduos, famílias e domicílios. Mas análises espaciais, que levam em conta vizinhanças e distâncias geográficas, por exemplo, também podem ser de interesse. Nesse caso, é importante ter ciência da granularidade dos dados – i.e. de qual a menor unidade espacial que permite inferência estatística. Para isso, cabe destacar as duas principais unidades espaciais na construção dos censos demográficos:\nSetores censitários\n\nOs setores censitários são a menor unidade de análise espacial nas pesquisas domiciliares do IBGE. Um setor é uma unidade territorial demarcada para fins operacionais de organizar a coleta de dados. Cada setor é coberto por um único recenseador e possui em média, cerca de 200 domicílios. No entanto, este número, assim como o tamanho do setor podem variar a depender da densidade demográfica de cada região. Os dados do universo são disponibilizados apenas no formato agregado por setores censitários.\nÁreas de ponderação\n\nAs áreas de ponderação são a menor unidade espacial para a qual os dados da pesquisa amostral possuem representatividade estatística. Essas áreas são constituídas por agrupamentos de setores censitários contíguos, mas que também variam de acordo com a densidade demográfica de cada região. Para o Censo de 2010, o IBGE estabeleceu que uma área de ponderação deveria ter, no mínimo, 400 domicílios ocupados na amostra. Em regiões menos densamente povoadas, essas áreas acabam ocupando uma larga extensão territorial.\n\n\nCódigolibrary(geobr)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(sf)\n\n# codigo do municipio de Belford Roxo\nmymuni &lt;- 3300456\n\n# baixa geometria do municipio\nmuni &lt;- geobr::read_municipality(mymuni)\n\n# baixa geometria das areas de ponderacao\nap &lt;- geobr::read_weighting_area(code_weighting = mymuni, \n                                 year = 2010, \n                                 simplified = F)\n\n# baixa geometria dos setores censitarios\nct &lt;- geobr::read_census_tract(code_tract = mymuni, \n                               year = 2010, \n                               simplified = FALSE)\n\n# funcao para 'inclinar' mapa\nrotate_data_geom &lt;- function(data, x_add = 0, y_add = 0) {\n  shear_matrix &lt;- function(){ matrix(c(2, 1.2, 0, 1), 2, 2) }\n  \n  rotate_matrix &lt;- function(x) { \n    matrix(c(cos(x), sin(x), -sin(x), cos(x)), 2, 2) \n  }\n  dplyr::mutate(data,\n    geom = geom * shear_matrix() * rotate_matrix(pi/20) + c(x_add, y_add)\n    )\n}\n\n\n# annotate parameters\nx = -116.03\nclr = 'gray40'\nsz = 4\n\n# MAP\ntemp1  &lt;- ggplot() +\n  # municipio\n  geom_sf(data = rotate_data_geom(data = muni, y_add = .01),\n          color='gray30', fill='#FCDE70', show.legend = FALSE) +\n  annotate(\"text\", label='Município', x=x, y=-4.59,\n           hjust = 0, color=clr, size=sz) +\n  \n  # areas de ponderacao\n  geom_sf(data = rotate_data_geom(data = ap, y_add = .07), \n          fill='#ff7b7b', color='#ff0000', show.legend = FALSE) +\n  annotate(\"text\", label='Áreas de\\nPonderação', x=x, y= -4.53,\n           hjust = 0, color=clr, size=sz) +\n\n  # setores censitarios\n  geom_sf(data = rotate_data_geom(data = ct, y_add = 0.13),\n          color='gray30', fill='gray98', show.legend = FALSE) +\n  annotate(\"text\", label='Setores\\nCensitários', x=x, y= -4.47, \n           hjust = 0, color=clr, size=sz) +\n  coord_sf(xlim = c(-116.305, -115.98)) +\n  theme_void() +\n  theme(plot.background = element_rect(fill = 'white', color='white'))\n\ntemp1\n# ggsave(temp1, filename = 'fig_spatial_layers.png', \n#        width = 12, height = 8, units = 'cm', dpi = 300)",
    "crumbs": [
      "Explorando o Censo Demográfico",
      "Conceitos iniciais do Censo"
    ]
  },
  {
    "objectID": "12_censobr_agregados_setores.html",
    "href": "12_censobr_agregados_setores.html",
    "title": "Agregados dos Setores Censitários",
    "section": "",
    "text": "Talvez os conjuntos de dados mais comumente usados dos censos brasileiros sejam os microdados de pessoas e domicílios. No entanto, o IBGE também disponibiliza dados muito ricos sobre as características populacionais e ambientais agregados no nível de setores censitários. Neste capítulo, mostramos como usar o pacote {censobr} para acessar facilmente esses dados usando a função read_tracts().\n\n\nNo seu formato original, os dados agregados no nível de setores censitários estão divididos em diferentes tipos de variáveis (e.g. variáveis de características de pessoas, de domicílios, etc). Em muitos casos, esses conjuntos de variáveis estão espalhadas por vários arquivos (em alguns casos com centenas variáveis). Para facilitar o entendimento desses dados, o {censobr} reúne todos os arquivos / variáveis em 8 tabelas:\n\n\"Basico\"\n\"Entorno\"\n\"Domicilio\"\n\"Pessoa\"\n\"Responsavel\"\n\"PessoaRenda\"\n\"DomicilioRenda\"\n\"ResponsavelRenda\"\n\nTodas estas tabelas estão organizadas seguindo a mesma lógica. Nos casos em que as variáveis de uma tabela provêm de arquivos diferentes, o nome da variável recebe um prefixo indicando a sua tabela de origem. Isso é feito para facilitar a consulta do significado de cada coluna no arquivo de dicionário variáveis (no próximo capítulo a gente vai ver como baixar os dicionários variáveis dos censos).\nPara ilustrar isso, vejamos a tabela com variáveis de \"Domicilio\". Essa tabela provêm de dois arquivos separados: Domicilio01 e Domicilio02. Assim, os nomes das colunas nessa tabela são organizados da seguinte maneira:\n\nlibrary(censobr)\n\n# baixa dados agregados de setores: variáveis de domicilios\ndom &lt;- read_tracts(year = 2010, \n                   dataset = 'Domicilio',\n                   as_data_frame = FALSE,\n                   showProgress = FALSE)\n\nnames(dom)[c(1:12,301:306)]\n\n [1] \"code_tract\"        \"code_weighting\"    \"code_muni\"        \n [4] \"code_state\"        \"abbrev_state\"      \"name_state\"       \n [7] \"code_region\"       \"name_region\"       \"domicilio01_V1005\"\n[10] \"domicilio01_V001\"  \"domicilio01_V002\"  \"domicilio01_V003\" \n[13] \"domicilio02_V050\"  \"domicilio02_V051\"  \"domicilio02_V052\" \n[16] \"domicilio02_V053\"  \"domicilio02_V054\"  \"domicilio02_V055\" \n\n\n\n\n\nPara verificar o significado de cada variável, você pode executar o comando data_dictionary(), que abrirá no navegador um arquivo .html ou .pdf com o dicionário de variáveis de cada conjunto de dados (ver mais info no capítulo 6 sobre Documentação).\n\ndata_dictionary(year = 2010,\n                dataset = 'tracts')\n\n\n\n\nEssa organização dos dados agregados por setores censitários parece confusa a primeira vista. E é mesmo. Mas essa organização fica mais clara com alguns exemplos práticos.\nNesta seção, nós vamos utilizar alguns exemplos para ilustrar como trabalhar com dados no nível de setor censitário. Primeiro, precisamos carregar as bibliotecas que usaremos neste tutorial.\n\nlibrary(censobr)\nlibrary(geobr)\nlibrary(arrow)\nlibrary(dplyr)\nlibrary(ggplot2)\n\nNos dois exemplos abaixo, usaremos a cidade de Belo Horizonte para fins de demonstração. No primeiro exemplo, nós vamos mapear a distribuição espacial da renda com dados de 2010. No segundo exemplo, nós vamos mapear a distribuição espacial da densidade populacional de BH com os dados preliminares do censo de 2022.\n\n\nNeste primeiro exemplo, criaremos um mapa da distribuição espacial da renda média per capita. A informação sobre o número total de residentes em cada setor censitário está disponível na tabela com conjunto de variáveis do bloco \"Basico\", na variável \"V002\". Já a informação sobre renda total do setor censiário pode ser encontradas na tabela do bloco \"DomicilioRenda\", na variável \"V003\".\nUtilizando o código abaixo, podemos baixar os dados e calcular a renda per capita de todos os setores censitários no Brasil. Posteriormente nós vamos filtrar esses resultados para ficar apenas com os setores de BH.\n\n# baixa os dados\n1tract_basico &lt;- read_tracts(year = 2010,\n                            dataset = \"Basico\",\n                            showProgress = FALSE)\n\n2tract_income &lt;- read_tracts(year = 2010,\n                            dataset = \"DomicilioRenda\",\n                            showProgress = FALSE)     \n\n# selecionar conlunas\n3tract_basico &lt;- tract_basico |&gt; select('code_tract','V002')\ntract_income &lt;- tract_income |&gt; select('code_tract','V003')\n\n# unir as tabelass\n4tracts_df10 &lt;- left_join(tract_basico, tract_income)\n                \n\n# calcular a renda per capita\ntracts_df10 &lt;- tracts_df10 |&gt; \n5                mutate(income_pc = V003 / V002) |&gt;\n6                collect()\n\nhead(tracts_df10)\n\n\n1\n\nDownload de dados do bloco Basico\n\n2\n\nDownload de dados do bloco DomicilioRenda\n\n3\n\nSeleciona apenas as variáveis que vamos utilizar\n\n4\n\nJunta as duas variáveis num único data.frame\n\n5\n\nCacula renda per capita de cada setor censitário\n\n6\n\nExtração dos resultados\n\n\n\n\n        code_tract  V002   V003 income_pc\n            &lt;char&gt; &lt;num&gt;  &lt;num&gt;     &lt;num&gt;\n1: 293076605000017   715 149721 209.40000\n2: 293076605000018   697 110160 158.04878\n3: 293076605000019   115  18905 164.39130\n4: 293076605000020   301  32147 106.80066\n5: 293076605000021    55   3904  70.98182\n6: 293076605000022   503  32177  63.97018\n\n\nO próximo passo é baixar as geometrias dos setores censitários de BH em 2010 com a função read_census_tract, do pacote {geobr}. Aqui, nós passamos o parâmetro code_tract = \"MG\" baixar os todos os setores do estado de Minas Gerais e depois filtramos apenas o município de Belo Horizonte.\n\n# busca qual o código do municipio de Belo Horizonte\nbh_info &lt;- geobr::lookup_muni(name_muni = 'Belo Horizonte')\n#&gt; code_muni: 3106200\n\n# baixa municipio de BH\nmuni_bh &lt;- geobr::read_municipality(code_muni = 'MG', \n                                    year = 2010,\n                                    showProgress = FALSE) |&gt;\n           filter(name_muni == \"Belo Horizonte\")\n\n# baixa todos setores de Minas Gerais\ntracts_2010 &lt;- geobr::read_census_tract(code_tract = \"MG\",\n                                        year = 2010,\n                                        simplified = FALSE,\n1                                        showProgress = FALSE)\n\n# filtra setores de BH\ntracts_2010 &lt;- filter(tracts_2010, name_muni == 'Belo Horizonte')\n\n# mapa de setores censitarios\nggplot() + \n  geom_sf(data=tracts_2010, fill = 'gray90', color='gray60') +\n  theme_void()\n\n\n1\n\nO comportamento padrão do {geobr} é baixar uma versão da malha espacial com geometrias ligeiramente simplificadas (simplified = TRUE) para agilizar o processamento e visualização de dados. Aqui, nós baixamos os dados com geometrias originais devido à escala espacial da visualização dos resultados.\n\n\n\n\n\n\n\n\n\n\n\nPor fim, a gente pode fazer um merge dos dados espaciais e de renda dos setores censitários usando como variável chave o código do setor censitário (code_tract) e criar o mapa da distribuição espacial da renda per capita do município.\n\nbh_tracts &lt;- left_join(tracts_2010, tracts_df10, by = 'code_tract')\n\nggplot() +\n  geom_sf(data = bh_tracts, aes(fill = ifelse(income_pc&lt;10000,income_pc,10000)), \n          color=NA) +\n  geom_sf(data = muni_bh, color='gray10', fill=NA) +\n  labs(title = 'Renda per capita dos setores censitários',\n       subtitle= 'Belo Horizonte, 2010') +\n  scale_fill_viridis_c(name = \"Reda per\\ncapita (R$)\",\n                       na.value=\"white\",\n                       option = 'cividis',\n                       breaks = c(0,  1e3, 4e3, 8e3, 1e4) ,\n                        labels  = c('0',  '1.000', '4.000', '8.000', '&gt; 10.000')\n                       ) +\n  theme_void()\n\n\n\n\n\n\n\n\n\n\n\nNeste segundo exemplo, nós vamos utilizar os resultados \"Preliminares\" dos agregados dos setores censitários do censo de 2022, que foram divulgados pelo IBGE em março de 2024. Em particular, vamos utilizar a variável V0001 que informa a população total dos setores. Além disso, como houve uma mudança na malha espacial de setores censitários entre 2010 e 2022, nós precisamos baixar a malha do ano correspondente.\n\n# download dados preliminares dos setores de 2022\ntracts_df22 &lt;- read_tracts(year = 2022,\n                          dataset = \"Preliminares\",\n                          showProgress = FALSE) |&gt;\n               filter(name_muni == 'Belo Horizonte') |&gt;\n               collect()\n\n# baixa todos setores de Minas Gerais\ntracts_2022 &lt;- geobr::read_census_tract(code_tract = \"MG\",\n                                        year = 2022,\n                                        simplified = FALSE,\n                                        showProgress = FALSE)\n\n# filtra setores de BH\ntracts_2022 &lt;- filter(tracts_2022, name_muni == 'Belo Horizonte')\n\nAgora a gente pode fazer um merge da tabela de população com os dados espaciais, calcular a área dos setores em Km2 e a densidade demográfica de cada setor, e criar o mapa.\n\n# merge tables\ntracts_df22$code_tract &lt;- as.numeric(tracts_df22$code_tract)\nbh_tracts22 &lt;- left_join(tracts_2022, tracts_df22, by = 'code_tract')\n\n# calcula a área dos setores\nbh_tracts22 &lt;- bh_tracts22 |&gt;\n              mutate(tract_aream2 = sf::st_area(tracts_2022),\n                     tract_areakm2 = units::set_units(tract_aream2, km2))\n\n# calcula densidade demografica\nbh_tracts22 &lt;- bh_tracts22 |&gt;\n               mutate(pop_km2 = as.numeric(V0001/ tract_areakm2))\n\n# map\nggplot() +\n  geom_sf(data = bh_tracts22, color=NA,\n          aes(fill = ifelse(pop_km2&lt;20000,pop_km2,20000))) +\n  geom_sf(data = muni_bh, color='gray10', fill=NA) +\n  labs(title = 'Densidade populacional dos setores censitários',\n       subtitle= 'Belo Horizonte, 2022') +\n  scale_fill_distiller(palette = \"Reds\", direction = 1, \n                       name='População por'~Km^2,\n                       breaks = c(0,  5e3, 10e3, 15e3, 2e4) ,\n                       labels  = c('0',  '5.000', '10.000', '15.000', '&gt; 20.000')) +\n  theme_void()",
    "crumbs": [
      "Explorando o Censo Demográfico",
      "Agregados dos Setores Censitários"
    ]
  },
  {
    "objectID": "12_censobr_agregados_setores.html#estrutura-dos-dados",
    "href": "12_censobr_agregados_setores.html#estrutura-dos-dados",
    "title": "Agregados dos Setores Censitários",
    "section": "",
    "text": "No seu formato original, os dados agregados no nível de setores censitários estão divididos em diferentes tipos de variáveis (e.g. variáveis de características de pessoas, de domicílios, etc). Em muitos casos, esses conjuntos de variáveis estão espalhadas por vários arquivos (em alguns casos com centenas variáveis). Para facilitar o entendimento desses dados, o {censobr} reúne todos os arquivos / variáveis em 8 tabelas:\n\n\"Basico\"\n\"Entorno\"\n\"Domicilio\"\n\"Pessoa\"\n\"Responsavel\"\n\"PessoaRenda\"\n\"DomicilioRenda\"\n\"ResponsavelRenda\"\n\nTodas estas tabelas estão organizadas seguindo a mesma lógica. Nos casos em que as variáveis de uma tabela provêm de arquivos diferentes, o nome da variável recebe um prefixo indicando a sua tabela de origem. Isso é feito para facilitar a consulta do significado de cada coluna no arquivo de dicionário variáveis (no próximo capítulo a gente vai ver como baixar os dicionários variáveis dos censos).\nPara ilustrar isso, vejamos a tabela com variáveis de \"Domicilio\". Essa tabela provêm de dois arquivos separados: Domicilio01 e Domicilio02. Assim, os nomes das colunas nessa tabela são organizados da seguinte maneira:\n\nlibrary(censobr)\n\n# baixa dados agregados de setores: variáveis de domicilios\ndom &lt;- read_tracts(year = 2010, \n                   dataset = 'Domicilio',\n                   as_data_frame = FALSE,\n                   showProgress = FALSE)\n\nnames(dom)[c(1:12,301:306)]\n\n [1] \"code_tract\"        \"code_weighting\"    \"code_muni\"        \n [4] \"code_state\"        \"abbrev_state\"      \"name_state\"       \n [7] \"code_region\"       \"name_region\"       \"domicilio01_V1005\"\n[10] \"domicilio01_V001\"  \"domicilio01_V002\"  \"domicilio01_V003\" \n[13] \"domicilio02_V050\"  \"domicilio02_V051\"  \"domicilio02_V052\" \n[16] \"domicilio02_V053\"  \"domicilio02_V054\"  \"domicilio02_V055\"",
    "crumbs": [
      "Explorando o Censo Demográfico",
      "Agregados dos Setores Censitários"
    ]
  },
  {
    "objectID": "12_censobr_agregados_setores.html#dicionário-de-variáveis",
    "href": "12_censobr_agregados_setores.html#dicionário-de-variáveis",
    "title": "Agregados dos Setores Censitários",
    "section": "",
    "text": "Para verificar o significado de cada variável, você pode executar o comando data_dictionary(), que abrirá no navegador um arquivo .html ou .pdf com o dicionário de variáveis de cada conjunto de dados (ver mais info no capítulo 6 sobre Documentação).\n\ndata_dictionary(year = 2010,\n                dataset = 'tracts')",
    "crumbs": [
      "Explorando o Censo Demográfico",
      "Agregados dos Setores Censitários"
    ]
  },
  {
    "objectID": "12_censobr_agregados_setores.html#exemplos-reproduzíveis",
    "href": "12_censobr_agregados_setores.html#exemplos-reproduzíveis",
    "title": "Agregados dos Setores Censitários",
    "section": "",
    "text": "Essa organização dos dados agregados por setores censitários parece confusa a primeira vista. E é mesmo. Mas essa organização fica mais clara com alguns exemplos práticos.\nNesta seção, nós vamos utilizar alguns exemplos para ilustrar como trabalhar com dados no nível de setor censitário. Primeiro, precisamos carregar as bibliotecas que usaremos neste tutorial.\n\nlibrary(censobr)\nlibrary(geobr)\nlibrary(arrow)\nlibrary(dplyr)\nlibrary(ggplot2)\n\nNos dois exemplos abaixo, usaremos a cidade de Belo Horizonte para fins de demonstração. No primeiro exemplo, nós vamos mapear a distribuição espacial da renda com dados de 2010. No segundo exemplo, nós vamos mapear a distribuição espacial da densidade populacional de BH com os dados preliminares do censo de 2022.\n\n\nNeste primeiro exemplo, criaremos um mapa da distribuição espacial da renda média per capita. A informação sobre o número total de residentes em cada setor censitário está disponível na tabela com conjunto de variáveis do bloco \"Basico\", na variável \"V002\". Já a informação sobre renda total do setor censiário pode ser encontradas na tabela do bloco \"DomicilioRenda\", na variável \"V003\".\nUtilizando o código abaixo, podemos baixar os dados e calcular a renda per capita de todos os setores censitários no Brasil. Posteriormente nós vamos filtrar esses resultados para ficar apenas com os setores de BH.\n\n# baixa os dados\n1tract_basico &lt;- read_tracts(year = 2010,\n                            dataset = \"Basico\",\n                            showProgress = FALSE)\n\n2tract_income &lt;- read_tracts(year = 2010,\n                            dataset = \"DomicilioRenda\",\n                            showProgress = FALSE)     \n\n# selecionar conlunas\n3tract_basico &lt;- tract_basico |&gt; select('code_tract','V002')\ntract_income &lt;- tract_income |&gt; select('code_tract','V003')\n\n# unir as tabelass\n4tracts_df10 &lt;- left_join(tract_basico, tract_income)\n                \n\n# calcular a renda per capita\ntracts_df10 &lt;- tracts_df10 |&gt; \n5                mutate(income_pc = V003 / V002) |&gt;\n6                collect()\n\nhead(tracts_df10)\n\n\n1\n\nDownload de dados do bloco Basico\n\n2\n\nDownload de dados do bloco DomicilioRenda\n\n3\n\nSeleciona apenas as variáveis que vamos utilizar\n\n4\n\nJunta as duas variáveis num único data.frame\n\n5\n\nCacula renda per capita de cada setor censitário\n\n6\n\nExtração dos resultados\n\n\n\n\n        code_tract  V002   V003 income_pc\n            &lt;char&gt; &lt;num&gt;  &lt;num&gt;     &lt;num&gt;\n1: 293076605000017   715 149721 209.40000\n2: 293076605000018   697 110160 158.04878\n3: 293076605000019   115  18905 164.39130\n4: 293076605000020   301  32147 106.80066\n5: 293076605000021    55   3904  70.98182\n6: 293076605000022   503  32177  63.97018\n\n\nO próximo passo é baixar as geometrias dos setores censitários de BH em 2010 com a função read_census_tract, do pacote {geobr}. Aqui, nós passamos o parâmetro code_tract = \"MG\" baixar os todos os setores do estado de Minas Gerais e depois filtramos apenas o município de Belo Horizonte.\n\n# busca qual o código do municipio de Belo Horizonte\nbh_info &lt;- geobr::lookup_muni(name_muni = 'Belo Horizonte')\n#&gt; code_muni: 3106200\n\n# baixa municipio de BH\nmuni_bh &lt;- geobr::read_municipality(code_muni = 'MG', \n                                    year = 2010,\n                                    showProgress = FALSE) |&gt;\n           filter(name_muni == \"Belo Horizonte\")\n\n# baixa todos setores de Minas Gerais\ntracts_2010 &lt;- geobr::read_census_tract(code_tract = \"MG\",\n                                        year = 2010,\n                                        simplified = FALSE,\n1                                        showProgress = FALSE)\n\n# filtra setores de BH\ntracts_2010 &lt;- filter(tracts_2010, name_muni == 'Belo Horizonte')\n\n# mapa de setores censitarios\nggplot() + \n  geom_sf(data=tracts_2010, fill = 'gray90', color='gray60') +\n  theme_void()\n\n\n1\n\nO comportamento padrão do {geobr} é baixar uma versão da malha espacial com geometrias ligeiramente simplificadas (simplified = TRUE) para agilizar o processamento e visualização de dados. Aqui, nós baixamos os dados com geometrias originais devido à escala espacial da visualização dos resultados.\n\n\n\n\n\n\n\n\n\n\n\nPor fim, a gente pode fazer um merge dos dados espaciais e de renda dos setores censitários usando como variável chave o código do setor censitário (code_tract) e criar o mapa da distribuição espacial da renda per capita do município.\n\nbh_tracts &lt;- left_join(tracts_2010, tracts_df10, by = 'code_tract')\n\nggplot() +\n  geom_sf(data = bh_tracts, aes(fill = ifelse(income_pc&lt;10000,income_pc,10000)), \n          color=NA) +\n  geom_sf(data = muni_bh, color='gray10', fill=NA) +\n  labs(title = 'Renda per capita dos setores censitários',\n       subtitle= 'Belo Horizonte, 2010') +\n  scale_fill_viridis_c(name = \"Reda per\\ncapita (R$)\",\n                       na.value=\"white\",\n                       option = 'cividis',\n                       breaks = c(0,  1e3, 4e3, 8e3, 1e4) ,\n                        labels  = c('0',  '1.000', '4.000', '8.000', '&gt; 10.000')\n                       ) +\n  theme_void()\n\n\n\n\n\n\n\n\n\n\n\nNeste segundo exemplo, nós vamos utilizar os resultados \"Preliminares\" dos agregados dos setores censitários do censo de 2022, que foram divulgados pelo IBGE em março de 2024. Em particular, vamos utilizar a variável V0001 que informa a população total dos setores. Além disso, como houve uma mudança na malha espacial de setores censitários entre 2010 e 2022, nós precisamos baixar a malha do ano correspondente.\n\n# download dados preliminares dos setores de 2022\ntracts_df22 &lt;- read_tracts(year = 2022,\n                          dataset = \"Preliminares\",\n                          showProgress = FALSE) |&gt;\n               filter(name_muni == 'Belo Horizonte') |&gt;\n               collect()\n\n# baixa todos setores de Minas Gerais\ntracts_2022 &lt;- geobr::read_census_tract(code_tract = \"MG\",\n                                        year = 2022,\n                                        simplified = FALSE,\n                                        showProgress = FALSE)\n\n# filtra setores de BH\ntracts_2022 &lt;- filter(tracts_2022, name_muni == 'Belo Horizonte')\n\nAgora a gente pode fazer um merge da tabela de população com os dados espaciais, calcular a área dos setores em Km2 e a densidade demográfica de cada setor, e criar o mapa.\n\n# merge tables\ntracts_df22$code_tract &lt;- as.numeric(tracts_df22$code_tract)\nbh_tracts22 &lt;- left_join(tracts_2022, tracts_df22, by = 'code_tract')\n\n# calcula a área dos setores\nbh_tracts22 &lt;- bh_tracts22 |&gt;\n              mutate(tract_aream2 = sf::st_area(tracts_2022),\n                     tract_areakm2 = units::set_units(tract_aream2, km2))\n\n# calcula densidade demografica\nbh_tracts22 &lt;- bh_tracts22 |&gt;\n               mutate(pop_km2 = as.numeric(V0001/ tract_areakm2))\n\n# map\nggplot() +\n  geom_sf(data = bh_tracts22, color=NA,\n          aes(fill = ifelse(pop_km2&lt;20000,pop_km2,20000))) +\n  geom_sf(data = muni_bh, color='gray10', fill=NA) +\n  labs(title = 'Densidade populacional dos setores censitários',\n       subtitle= 'Belo Horizonte, 2022') +\n  scale_fill_distiller(palette = \"Reds\", direction = 1, \n                       name='População por'~Km^2,\n                       breaks = c(0,  5e3, 10e3, 15e3, 2e4) ,\n                       labels  = c('0',  '5.000', '10.000', '15.000', '&gt; 20.000')) +\n  theme_void()",
    "crumbs": [
      "Explorando o Censo Demográfico",
      "Agregados dos Setores Censitários"
    ]
  },
  {
    "objectID": "LICENSE.html",
    "href": "LICENSE.html",
    "title": "Introdução à análise de dados no R",
    "section": "",
    "text": "Attribution-ShareAlike 4.0 International\n=======================================================================\nCreative Commons Corporation (“Creative Commons”) is not a law firm and does not provide legal services or legal advice. Distribution of Creative Commons public licenses does not create a lawyer-client or other relationship. Creative Commons makes its licenses and related information available on an “as-is” basis. Creative Commons gives no warranties regarding its licenses, any material licensed under their terms and conditions, or any related information. Creative Commons disclaims all liability for damages resulting from their use to the fullest extent possible.\nUsing Creative Commons Public Licenses\nCreative Commons public licenses provide a standard set of terms and conditions that creators and other rights holders may use to share original works of authorship and other material subject to copyright and certain other rights specified in the public license below. The following considerations are for informational purposes only, are not exhaustive, and do not form part of our licenses.\n Considerations for licensors: Our public licenses are\n intended for use by those authorized to give the public\n permission to use material in ways otherwise restricted by\n copyright and certain other rights. Our licenses are\n irrevocable. Licensors should read and understand the terms\n and conditions of the license they choose before applying it.\n Licensors should also secure all rights necessary before\n applying our licenses so that the public can reuse the\n material as expected. Licensors should clearly mark any\n material not subject to the license. This includes other CC-\n licensed material, or material used under an exception or\n limitation to copyright. More considerations for licensors:\nwiki.creativecommons.org/Considerations_for_licensors\n\n Considerations for the public: By using one of our public\n licenses, a licensor grants the public permission to use the\n licensed material under specified terms and conditions. If\n the licensor's permission is not necessary for any reason--for\n example, because of any applicable exception or limitation to\n copyright--then that use is not regulated by the license. Our\n licenses grant only permissions under copyright and certain\n other rights that a licensor has authority to grant. Use of\n the licensed material may still be restricted for other\n reasons, including because others have copyright or other\n rights in the material. A licensor may make special requests,\n such as asking that all changes be marked or described.\n Although not required by our licenses, you are encouraged to\n respect those requests where reasonable. More considerations\n for the public:\nwiki.creativecommons.org/Considerations_for_licensees\n=======================================================================\nCreative Commons Attribution-ShareAlike 4.0 International Public License\nBy exercising the Licensed Rights (defined below), You accept and agree to be bound by the terms and conditions of this Creative Commons Attribution-ShareAlike 4.0 International Public License (“Public License”). To the extent this Public License may be interpreted as a contract, You are granted the Licensed Rights in consideration of Your acceptance of these terms and conditions, and the Licensor grants You such rights in consideration of benefits the Licensor receives from making the Licensed Material available under these terms and conditions.\nSection 1 – Definitions.\n\nAdapted Material means material subject to Copyright and Similar Rights that is derived from or based upon the Licensed Material and in which the Licensed Material is translated, altered, arranged, transformed, or otherwise modified in a manner requiring permission under the Copyright and Similar Rights held by the Licensor. For purposes of this Public License, where the Licensed Material is a musical work, performance, or sound recording, Adapted Material is always produced where the Licensed Material is synched in timed relation with a moving image.\nAdapter’s License means the license You apply to Your Copyright and Similar Rights in Your contributions to Adapted Material in accordance with the terms and conditions of this Public License.\nBY-SA Compatible License means a license listed at creativecommons.org/compatiblelicenses, approved by Creative Commons as essentially the equivalent of this Public License.\nCopyright and Similar Rights means copyright and/or similar rights closely related to copyright including, without limitation, performance, broadcast, sound recording, and Sui Generis Database Rights, without regard to how the rights are labeled or categorized. For purposes of this Public License, the rights specified in Section 2(b)(1)-(2) are not Copyright and Similar Rights.\nEffective Technological Measures means those measures that, in the absence of proper authority, may not be circumvented under laws fulfilling obligations under Article 11 of the WIPO Copyright Treaty adopted on December 20, 1996, and/or similar international agreements.\nExceptions and Limitations means fair use, fair dealing, and/or any other exception or limitation to Copyright and Similar Rights that applies to Your use of the Licensed Material.\nLicense Elements means the license attributes listed in the name of a Creative Commons Public License. The License Elements of this Public License are Attribution and ShareAlike.\nLicensed Material means the artistic or literary work, database, or other material to which the Licensor applied this Public License.\nLicensed Rights means the rights granted to You subject to the terms and conditions of this Public License, which are limited to all Copyright and Similar Rights that apply to Your use of the Licensed Material and that the Licensor has authority to license.\nLicensor means the individual(s) or entity(ies) granting rights under this Public License.\nShare means to provide material to the public by any means or process that requires permission under the Licensed Rights, such as reproduction, public display, public performance, distribution, dissemination, communication, or importation, and to make material available to the public including in ways that members of the public may access the material from a place and at a time individually chosen by them.\nSui Generis Database Rights means rights other than copyright resulting from Directive 96/9/EC of the European Parliament and of the Council of 11 March 1996 on the legal protection of databases, as amended and/or succeeded, as well as other essentially equivalent rights anywhere in the world.\nYou means the individual or entity exercising the Licensed Rights under this Public License. Your has a corresponding meaning.\n\nSection 2 – Scope.\n\nLicense grant.\n\nSubject to the terms and conditions of this Public License, the Licensor hereby grants You a worldwide, royalty-free, non-sublicensable, non-exclusive, irrevocable license to exercise the Licensed Rights in the Licensed Material to:\n\nreproduce and Share the Licensed Material, in whole or in part; and\nproduce, reproduce, and Share Adapted Material.\n\nExceptions and Limitations. For the avoidance of doubt, where Exceptions and Limitations apply to Your use, this Public License does not apply, and You do not need to comply with its terms and conditions.\nTerm. The term of this Public License is specified in Section 6(a).\nMedia and formats; technical modifications allowed. The Licensor authorizes You to exercise the Licensed Rights in all media and formats whether now known or hereafter created, and to make technical modifications necessary to do so. The Licensor waives and/or agrees not to assert any right or authority to forbid You from making technical modifications necessary to exercise the Licensed Rights, including technical modifications necessary to circumvent Effective Technological Measures. For purposes of this Public License, simply making modifications authorized by this Section 2(a)\n\nnever produces Adapted Material.\n\nDownstream recipients.\n\nOffer from the Licensor – Licensed Material. Every recipient of the Licensed Material automatically receives an offer from the Licensor to exercise the Licensed Rights under the terms and conditions of this Public License.\nAdditional offer from the Licensor – Adapted Material. Every recipient of Adapted Material from You automatically receives an offer from the Licensor to exercise the Licensed Rights in the Adapted Material under the conditions of the Adapter’s License You apply.\nNo downstream restrictions. You may not offer or impose any additional or different terms or conditions on, or apply any Effective Technological Measures to, the Licensed Material if doing so restricts exercise of the Licensed Rights by any recipient of the Licensed Material.\n\nNo endorsement. Nothing in this Public License constitutes or may be construed as permission to assert or imply that You are, or that Your use of the Licensed Material is, connected with, or sponsored, endorsed, or granted official status by, the Licensor or others designated to receive attribution as provided in Section 3(a)(1)(A)(i).\n\nOther rights.\n\nMoral rights, such as the right of integrity, are not licensed under this Public License, nor are publicity, privacy, and/or other similar personality rights; however, to the extent possible, the Licensor waives and/or agrees not to assert any such rights held by the Licensor to the limited extent necessary to allow You to exercise the Licensed Rights, but not otherwise.\nPatent and trademark rights are not licensed under this Public License.\nTo the extent possible, the Licensor waives any right to collect royalties from You for the exercise of the Licensed Rights, whether directly or through a collecting society under any voluntary or waivable statutory or compulsory licensing scheme. In all other cases the Licensor expressly reserves any right to collect such royalties.\n\n\nSection 3 – License Conditions.\nYour exercise of the Licensed Rights is expressly made subject to the following conditions.\n\nAttribution.\n\nIf You Share the Licensed Material (including in modified form), You must:\n\nretain the following if it is supplied by the Licensor with the Licensed Material:\n\nidentification of the creator(s) of the Licensed Material and any others designated to receive attribution, in any reasonable manner requested by the Licensor (including by pseudonym if designated);\na copyright notice;\na notice that refers to this Public License;\na notice that refers to the disclaimer of warranties;\na URI or hyperlink to the Licensed Material to the extent reasonably practicable;\n\nindicate if You modified the Licensed Material and retain an indication of any previous modifications; and\nindicate the Licensed Material is licensed under this Public License, and include the text of, or the URI or hyperlink to, this Public License.\n\nYou may satisfy the conditions in Section 3(a)(1) in any reasonable manner based on the medium, means, and context in which You Share the Licensed Material. For example, it may be reasonable to satisfy the conditions by providing a URI or hyperlink to a resource that includes the required information.\nIf requested by the Licensor, You must remove any of the information required by Section 3(a)(1)(A) to the extent reasonably practicable.\n\nShareAlike.\nIn addition to the conditions in Section 3(a), if You Share Adapted Material You produce, the following conditions also apply.\n\nThe Adapter’s License You apply must be a Creative Commons license with the same License Elements, this version or later, or a BY-SA Compatible License.\nYou must include the text of, or the URI or hyperlink to, the Adapter’s License You apply. You may satisfy this condition in any reasonable manner based on the medium, means, and context in which You Share Adapted Material.\nYou may not offer or impose any additional or different terms or conditions on, or apply any Effective Technological Measures to, Adapted Material that restrict exercise of the rights granted under the Adapter’s License You apply.\n\n\nSection 4 – Sui Generis Database Rights.\nWhere the Licensed Rights include Sui Generis Database Rights that apply to Your use of the Licensed Material:\n\nfor the avoidance of doubt, Section 2(a)(1) grants You the right to extract, reuse, reproduce, and Share all or a substantial portion of the contents of the database;\nif You include all or a substantial portion of the database contents in a database in which You have Sui Generis Database Rights, then the database in which You have Sui Generis Database Rights (but not its individual contents) is Adapted Material, including for purposes of Section 3(b); and\nYou must comply with the conditions in Section 3(a) if You Share all or a substantial portion of the contents of the database.\n\nFor the avoidance of doubt, this Section 4 supplements and does not replace Your obligations under this Public License where the Licensed Rights include other Copyright and Similar Rights.\nSection 5 – Disclaimer of Warranties and Limitation of Liability.\n\nUNLESS OTHERWISE SEPARATELY UNDERTAKEN BY THE LICENSOR, TO THE EXTENT POSSIBLE, THE LICENSOR OFFERS THE LICENSED MATERIAL AS-IS AND AS-AVAILABLE, AND MAKES NO REPRESENTATIONS OR WARRANTIES OF ANY KIND CONCERNING THE LICENSED MATERIAL, WHETHER EXPRESS, IMPLIED, STATUTORY, OR OTHER. THIS INCLUDES, WITHOUT LIMITATION, WARRANTIES OF TITLE, MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT, ABSENCE OF LATENT OR OTHER DEFECTS, ACCURACY, OR THE PRESENCE OR ABSENCE OF ERRORS, WHETHER OR NOT KNOWN OR DISCOVERABLE. WHERE DISCLAIMERS OF WARRANTIES ARE NOT ALLOWED IN FULL OR IN PART, THIS DISCLAIMER MAY NOT APPLY TO YOU.\nTO THE EXTENT POSSIBLE, IN NO EVENT WILL THE LICENSOR BE LIABLE TO YOU ON ANY LEGAL THEORY (INCLUDING, WITHOUT LIMITATION, NEGLIGENCE) OR OTHERWISE FOR ANY DIRECT, SPECIAL, INDIRECT, INCIDENTAL, CONSEQUENTIAL, PUNITIVE, EXEMPLARY, OR OTHER LOSSES, COSTS, EXPENSES, OR DAMAGES ARISING OUT OF THIS PUBLIC LICENSE OR USE OF THE LICENSED MATERIAL, EVEN IF THE LICENSOR HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH LOSSES, COSTS, EXPENSES, OR DAMAGES. WHERE A LIMITATION OF LIABILITY IS NOT ALLOWED IN FULL OR IN PART, THIS LIMITATION MAY NOT APPLY TO YOU.\nThe disclaimer of warranties and limitation of liability provided above shall be interpreted in a manner that, to the extent possible, most closely approximates an absolute disclaimer and waiver of all liability.\n\nSection 6 – Term and Termination.\n\nThis Public License applies for the term of the Copyright and Similar Rights licensed here. However, if You fail to comply with this Public License, then Your rights under this Public License terminate automatically.\nWhere Your right to use the Licensed Material has terminated under Section 6(a), it reinstates:\n\nautomatically as of the date the violation is cured, provided it is cured within 30 days of Your discovery of the violation; or\nupon express reinstatement by the Licensor.\n\nFor the avoidance of doubt, this Section 6(b) does not affect any right the Licensor may have to seek remedies for Your violations of this Public License.\nFor the avoidance of doubt, the Licensor may also offer the Licensed Material under separate terms or conditions or stop distributing the Licensed Material at any time; however, doing so will not terminate this Public License.\nSections 1, 5, 6, 7, and 8 survive termination of this Public License.\n\nSection 7 – Other Terms and Conditions.\n\nThe Licensor shall not be bound by any additional or different terms or conditions communicated by You unless expressly agreed.\nAny arrangements, understandings, or agreements regarding the Licensed Material not stated herein are separate from and independent of the terms and conditions of this Public License.\n\nSection 8 – Interpretation.\n\nFor the avoidance of doubt, this Public License does not, and shall not be interpreted to, reduce, limit, restrict, or impose conditions on any use of the Licensed Material that could lawfully be made without permission under this Public License.\nTo the extent possible, if any provision of this Public License is deemed unenforceable, it shall be automatically reformed to the minimum extent necessary to make it enforceable. If the provision cannot be reformed, it shall be severed from this Public License without affecting the enforceability of the remaining terms and conditions.\nNo term or condition of this Public License will be waived and no failure to comply consented to unless expressly agreed to by the Licensor.\nNothing in this Public License constitutes or may be interpreted as a limitation upon, or waiver of, any privileges and immunities that apply to the Licensor or You, including from the legal processes of any jurisdiction or authority.\n\n=======================================================================\nCreative Commons is not a party to its public licenses. Notwithstanding, Creative Commons may elect to apply one of its public licenses to material it publishes and in those instances will be considered the “Licensor.” The text of the Creative Commons public licenses is dedicated to the public domain under the CC0 Public Domain Dedication. Except for the limited purpose of indicating that material is shared under a Creative Commons public license or as otherwise permitted by the Creative Commons policies published at creativecommons.org/policies, Creative Commons does not authorize the use of the trademark “Creative Commons” or any other trademark or logo of Creative Commons without its prior written consent including, without limitation, in connection with any unauthorized modifications to any of its public licenses or any other arrangements, understandings, or agreements concerning use of licensed material. For the avoidance of doubt, this paragraph does not form part of the public licenses.\nCreative Commons may be contacted at creativecommons.org."
  },
  {
    "objectID": "09_censobr_intro.html",
    "href": "09_censobr_intro.html",
    "title": "Explorando o Censo Demográfico",
    "section": "",
    "text": "O Censo Demográfico é uma das mais importantes fontes de dados sobre as características e condições de vida da população brasileira. Nesta aula, você vai aprender como baixar e manipular os dados das diversas edições do censo demográfico do Brasil de 1960 a 2022 usando o pacote {censobr} na linguagem de programação R.\nA oficina também vai demonstrar como o {censobr} permite trabalhar com grandes bases de dados (larger-than-memory data) e ser integrado com o pacote {geobr} para visualização espacial de dados em diferentes escalas geográficas.\n{censobr} e {geobr}\nO {censobr} é um pacote de R para acessar os dados e documentação dos censos demográficos do Brasil (Pereira e Barbosa 2023). O pacote disponibiliza microdados da amostra de todas as edições do censo demográfico desde 1960 (mais informações no site do pacote).\nPor sua vez, oO {geobr} é um pacote para baixar dados espaciais oficiais do Brasil (Pereira e Gonçalves 2019). Ele inclui uma ampla variedade de dados geoespaciais disponíveis em várias escalas geográficas e para diversos anos, como municípios, regiões metropolitanas, biomas, estabelecimentos de saúde, etc (veja a lista completa no site do pacote).\n\n\n\n\n\n\n\n\n\n\n\nInstalando pacotes de R para essa aula\nPara esta aula, você vai precisar dos pacotes abaixo instalados na máquina. A maneira mais simples de fazer isso é executando o código abaixo. Isso pode levar alguns minutos, caso seja a primeira vez que você instala esses pacotes.\n\npkgs &lt;- c(\n  'censobr',\n  'geobr',\n  'arrow',\n  'dplyr',\n  'ggplot2',\n  'quantreg',\n  'sf'\n  )\n\ninstall.packages(pkgs)\n\n\n\n\nReferências\n\nPereira, Rafael H. M., e Rogério J. Barbosa. 2023. censobr: Download Data from Brazil’s Population Census. CRAN. https://doi.org/10.32614/CRAN.package.censobr.\n\n\nPereira, Rafael H. M., e Caio N. Gonçalves. 2019. geobr: Download Official Spatial Data Sets of Brazil. CRAN. https://doi.org/10.32614/CRAN.package.geobr.",
    "crumbs": [
      "Explorando o Censo Demográfico",
      "Explorando o Censo Demográfico"
    ]
  },
  {
    "objectID": "08_visualizacao.html",
    "href": "08_visualizacao.html",
    "title": "Visualizando dados",
    "section": "",
    "text": "Aviso\n\n\n\nPágina em construção! Em breve.",
    "crumbs": [
      "Materiais",
      "Visualizando dados"
    ]
  },
  {
    "objectID": "08_visualizacao.html#sugestões-de-materiais",
    "href": "08_visualizacao.html#sugestões-de-materiais",
    "title": "Visualizando dados",
    "section": "Sugestões de materiais",
    "text": "Sugestões de materiais\n\nLivro R para Ciência de Dados 2ed:\n\nVisualização de dados\nVsualizar\nVisualizar: Camadas\nVisualizar: Análise exploratória de dados\nVisualizar: Comunicação\n\nLivro: Metodologia de Pesquisa Jurimétrica:\n\nCapítulo 4 - Visualização",
    "crumbs": [
      "Materiais",
      "Visualizando dados"
    ]
  },
  {
    "objectID": "05_transformacao.html",
    "href": "05_transformacao.html",
    "title": "Transformando dados",
    "section": "",
    "text": "Primeiramente, precisamos carregar o pacote tidyverse e a base de dados que vamos utilizar. A base de dados é a tabela 4092 do SIDRA, que apresenta dados sobre “pessoas de 14 anos ou mais de idade por condição em relação à força de trabalho e condição de ocupação”, e foi baixada previamente (em Importando dados).\n\nlibrary(tidyverse)\ndados_brutos &lt;- read_csv2(\"dados/sidrar_4092_bruto_2.csv\")\n\nUma pergunta que é sempre importante ter em mente ao analisar dados é: O que cada linha representa?\nO objeto dados_brutos apresenta uma linha para cada combinação das seguintes variáveis:\n\nTrimestre (Código) / Trimestre\nUnidade da Federação / Unidade da Federação (Código)\nVariável / Variável (Código)\nCondição em relação à força de trabalho e condição de ocupação e Condição em relação à força de trabalho e condição de ocupação (Código)\n\nOu seja, cada linha representa uma combinação de trimestre, unidade da federação e variável. Outras perguntas relevantes ao analisar dados são:\n\nQual é a pergunta que eu quero responder com esses dados?\nQuais são as variáveis que eu preciso para responder essa pergunta?\n\nNeste capítulo, vamos explorar as funções de transformação de dados do pacote dplyr, usando uma pergunta norteadora como exemplo:\n\nConsiderando que a tabela 4092 apresenta dados sobre “pessoas de 14 anos ou mais de idade por condição em relação à força de trabalho e condição de ocupação”, qual é a taxa de desocupação de cada estado e região do Brasil ao longo do tempo?",
    "crumbs": [
      "Materiais",
      "Transformando dados"
    ]
  },
  {
    "objectID": "05_transformacao.html#introdução",
    "href": "05_transformacao.html#introdução",
    "title": "Transformando dados",
    "section": "",
    "text": "Primeiramente, precisamos carregar o pacote tidyverse e a base de dados que vamos utilizar. A base de dados é a tabela 4092 do SIDRA, que apresenta dados sobre “pessoas de 14 anos ou mais de idade por condição em relação à força de trabalho e condição de ocupação”, e foi baixada previamente (em Importando dados).\n\nlibrary(tidyverse)\ndados_brutos &lt;- read_csv2(\"dados/sidrar_4092_bruto_2.csv\")\n\nUma pergunta que é sempre importante ter em mente ao analisar dados é: O que cada linha representa?\nO objeto dados_brutos apresenta uma linha para cada combinação das seguintes variáveis:\n\nTrimestre (Código) / Trimestre\nUnidade da Federação / Unidade da Federação (Código)\nVariável / Variável (Código)\nCondição em relação à força de trabalho e condição de ocupação e Condição em relação à força de trabalho e condição de ocupação (Código)\n\nOu seja, cada linha representa uma combinação de trimestre, unidade da federação e variável. Outras perguntas relevantes ao analisar dados são:\n\nQual é a pergunta que eu quero responder com esses dados?\nQuais são as variáveis que eu preciso para responder essa pergunta?\n\nNeste capítulo, vamos explorar as funções de transformação de dados do pacote dplyr, usando uma pergunta norteadora como exemplo:\n\nConsiderando que a tabela 4092 apresenta dados sobre “pessoas de 14 anos ou mais de idade por condição em relação à força de trabalho e condição de ocupação”, qual é a taxa de desocupação de cada estado e região do Brasil ao longo do tempo?",
    "crumbs": [
      "Materiais",
      "Transformando dados"
    ]
  },
  {
    "objectID": "05_transformacao.html#padronizar-nome-das-colunas",
    "href": "05_transformacao.html#padronizar-nome-das-colunas",
    "title": "Transformando dados",
    "section": "Padronizar nome das colunas",
    "text": "Padronizar nome das colunas\nÉ uma boa prática padronizar o nome das colunas de um data frame. Assim evitamos problemas encoding e também facilitamos a legibilidade do código e evitamos possíveis erros ao acessar as colunas.\nO pacote janitor possui a função clean_names(), que padroniza os nomes das colunas de um data frame. Ele substitui espaços por underline, remove caracteres especiais, e transforma o texto em minúsculo, garantindo maior consistência ao lidar com os dados. Isso evita erros ao acessar colunas.\n\nlibrary(janitor)\n\n\n# checar nome das colunas da base de dados\nnames(dados_brutos)\n\n [1] \"Nível Territorial (Código)\"                                             \n [2] \"Nível Territorial\"                                                      \n [3] \"Unidade de Medida (Código)\"                                             \n [4] \"Unidade de Medida\"                                                      \n [5] \"Valor\"                                                                  \n [6] \"Unidade da Federação (Código)\"                                          \n [7] \"Unidade da Federação\"                                                   \n [8] \"Trimestre (Código)\"                                                     \n [9] \"Trimestre\"                                                              \n[10] \"Variável (Código)\"                                                      \n[11] \"Variável\"                                                               \n[12] \"Condição em relação à força de trabalho e condição de ocupação (Código)\"\n[13] \"Condição em relação à força de trabalho e condição de ocupação\"         \n\n# limpar nomes das colunas da base de dados, e salvar em um novo objeto\ndados_renomeados &lt;- clean_names(dados_brutos)\n\n# checar nome das colunas da base de dados renomeada\nnames(dados_renomeados)\n\n [1] \"nivel_territorial_codigo\"                                             \n [2] \"nivel_territorial\"                                                    \n [3] \"unidade_de_medida_codigo\"                                             \n [4] \"unidade_de_medida\"                                                    \n [5] \"valor\"                                                                \n [6] \"unidade_da_federacao_codigo\"                                          \n [7] \"unidade_da_federacao\"                                                 \n [8] \"trimestre_codigo\"                                                     \n [9] \"trimestre\"                                                            \n[10] \"variavel_codigo\"                                                      \n[11] \"variavel\"                                                             \n[12] \"condicao_em_relacao_a_forca_de_trabalho_e_condicao_de_ocupacao_codigo\"\n[13] \"condicao_em_relacao_a_forca_de_trabalho_e_condicao_de_ocupacao\"",
    "crumbs": [
      "Materiais",
      "Transformando dados"
    ]
  },
  {
    "objectID": "05_transformacao.html#filtrando-linhas",
    "href": "05_transformacao.html#filtrando-linhas",
    "title": "Transformando dados",
    "section": "Filtrando linhas",
    "text": "Filtrando linhas\nPara responder a pergunta, não precisamos de todas as variáveis presentes na base de dados. Portanto, podemos filtrar as linhas que são relevantes para a análise.\nAntes de filtrar, podemos consultar os valores distintos possíveis, para garantir que estamos selecionando corretamente o valor de interesse ao aplicar o filtro. Isso ajuda a prevenir erros e garante que o filtro está sendo feito de maneira adequada.\nAs variáveis disponíveis na base de dados, e suas unidades de medida são:\n\ndistinct(\n  # base de dados\n  dados_renomeados, \n  # colunas que queremos bucar os valores distintos \n  variavel, unidade_de_medida\n)\n\n# A tibble: 4 × 2\n  variavel                                                     unidade_de_medida\n  &lt;chr&gt;                                                        &lt;chr&gt;            \n1 Pessoas de 14 anos ou mais de idade                          Mil pessoas      \n2 Coeficiente de variação - Pessoas de 14 anos ou mais de ida… %                \n3 Distribuição percentual das pessoas de 14 anos ou mais de i… %                \n4 Coeficiente de variação - Distribuição percentual das pesso… %                \n\n\nNesse caso, podemos filtrar os dados onde a variável é igual à \"Pessoas de 14 anos ou mais de idade\".\n\ndados_filtrados &lt;- filter(\n  # base de dados\n  dados_renomeados,\n  # condição de filtro\n  variavel == \"Pessoas de 14 anos ou mais de idade\"\n)\n\nPara verificar se o filtro foi feita corretamente, podemos checar o número de linhas de cada base de dados:\n\nnrow(dados_renomeados)\n\n[1] 27000\n\nnrow(dados_filtrados)\n\n[1] 6750\n\n\nPodemos verificar também os valores distintos para as colunas variavel e unidade_de_medida na base de dados dados_filtrados:\n\ndistinct(\n  # base de dados\n  dados_filtrados, \n  # colunas que queremos bucar os valores distintos \n  variavel, unidade_de_medida\n)\n\n# A tibble: 1 × 2\n  variavel                            unidade_de_medida\n  &lt;chr&gt;                               &lt;chr&gt;            \n1 Pessoas de 14 anos ou mais de idade Mil pessoas      \n\n\nAgora sabemos que a base de dados dados_filtrados contém apenas dados sobre a variável \"Pessoas de 14 anos ou mais de idade\", e que a unidade de medida da coluna valor é mil pessoas.",
    "crumbs": [
      "Materiais",
      "Transformando dados"
    ]
  },
  {
    "objectID": "05_transformacao.html#selecionando-colunas",
    "href": "05_transformacao.html#selecionando-colunas",
    "title": "Transformando dados",
    "section": "Selecionando colunas",
    "text": "Selecionando colunas\nAlgumas colunas apresentam valores que não são relevantes para a análise. Portanto, podemos selecionar apenas as colunas que são vamos utilizar, utilizando a função select().\n\ndados_selecionados &lt;- select(\n  # base de dados\n  dados_filtrados, \n  # colunas que queremos manter\n  unidade_da_federacao,\n  unidade_da_federacao_codigo,\n  trimestre,\n  trimestre_codigo,\n  condicao_em_relacao_a_forca_de_trabalho_e_condicao_de_ocupacao,\n  valor\n)\n\nPodemos renomear colunas com a função rename(). Vamos renomear algumas colunas para facilitar o uso posteriormente:\n\ndados_renomeados_2 &lt;- rename(\n  # base de dados\n  dados_selecionados, \n  # colunas que queremos renomear: novo_nome = nome_atual\n  condicao = condicao_em_relacao_a_forca_de_trabalho_e_condicao_de_ocupacao,\n  valor_mil_pessoas = valor,\n  uf = unidade_da_federacao,\n  uf_codigo = unidade_da_federacao_codigo\n)\n\nglimpse(dados_renomeados_2)\n\nRows: 6,750\nColumns: 6\n$ uf                &lt;chr&gt; \"Rondônia\", \"Rondônia\", \"Rondônia\", \"Rondônia\", \"Ron…\n$ uf_codigo         &lt;dbl&gt; 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, …\n$ trimestre         &lt;chr&gt; \"1º trimestre 2012\", \"1º trimestre 2012\", \"1º trimes…\n$ trimestre_codigo  &lt;dbl&gt; 201201, 201201, 201201, 201201, 201201, 201202, 2012…\n$ condicao          &lt;chr&gt; \"Total\", \"Força de trabalho\", \"Força de trabalho - o…\n$ valor_mil_pessoas &lt;dbl&gt; 1210, 765, 703, 62, 446, 1217, 782, 733, 49, 434, 12…",
    "crumbs": [
      "Materiais",
      "Transformando dados"
    ]
  },
  {
    "objectID": "05_transformacao.html#transformando-a-tabela",
    "href": "05_transformacao.html#transformando-a-tabela",
    "title": "Transformando dados",
    "section": "Transformando a tabela",
    "text": "Transformando a tabela\nVoltando à pergunta norteadora, queremos calcular a taxa de desocupação de cada estado e região do Brasil ao longo do tempo. Para isso, é mais fácil trabalhar com a tabela onde cada linha represente uma UF por trimestre, e as categorias da variável condicao sejam transformadas em colunas.\nPara fazer essa transformação, podemos usar a função pivot_wider().\nA função pivot_wider() é útil quando queremos reorganizar uma tabela, transformando variáveis categóricas em novas colunas. Essa estrutura facilita cálculos comparativos e análises entre as diferentes categorias.\nPor exemplo, no formato atual (dados longos), temos uma linha para cada combinação de UF, trimestre e condição de ocupação. Ao usarmos pivot_wider(), vamos transformar a tabela para que cada linha represente uma UF por trimestre, e as diferentes condições de ocupação (empregado, desocupado, etc.) se tornem colunas.\n\ndados_largos &lt;- pivot_wider(\n  # base de dados\n  dados_renomeados_2, \n  # nome da coluna de onde os nomes das novas colunas serão extraídos\n  names_from = condicao, \n  # nome da coluna de onde os valores das novas colunas serão extraídos \n  values_from = valor_mil_pessoas, \n  # podemos adicionar um texto como prefixo. nesse caso, isso é opcional, \n  # mas é útil para ficar claro qual é a unidade de medida das variáveis\n  names_prefix = \"mil_pessoas_\"\n)\n\n\nglimpse(dados_largos)\n\nRows: 1,350\nColumns: 9\n$ uf                                           &lt;chr&gt; \"Rondônia\", \"Rondônia\", \"…\n$ uf_codigo                                    &lt;dbl&gt; 11, 11, 11, 11, 11, 11, 1…\n$ trimestre                                    &lt;chr&gt; \"1º trimestre 2012\", \"2º …\n$ trimestre_codigo                             &lt;dbl&gt; 201201, 201202, 201203, 2…\n$ mil_pessoas_Total                            &lt;dbl&gt; 1210, 1217, 1226, 1219, 1…\n$ `mil_pessoas_Força de trabalho`              &lt;dbl&gt; 765, 782, 784, 805, 796, …\n$ `mil_pessoas_Força de trabalho - ocupada`    &lt;dbl&gt; 703, 733, 738, 762, 746, …\n$ `mil_pessoas_Força de trabalho - desocupada` &lt;dbl&gt; 62, 49, 46, 42, 49, 39, 3…\n$ `mil_pessoas_Fora da força de trabalho`      &lt;dbl&gt; 446, 434, 441, 415, 437, …\n\n\nAgora temos uma tabela onde cada linha representa uma UF por trimestre, e as categorias da variável condicao se tornaram colunas. Porém agora temos colunas com nomes que estão com caracteres especiais, e podemos arrumar isso com a função clean_names().\n\ndados_largos_renomeados &lt;- clean_names(dados_largos)\nglimpse(dados_largos_renomeados)\n\nRows: 1,350\nColumns: 9\n$ uf                                       &lt;chr&gt; \"Rondônia\", \"Rondônia\", \"Rond…\n$ uf_codigo                                &lt;dbl&gt; 11, 11, 11, 11, 11, 11, 11, 1…\n$ trimestre                                &lt;chr&gt; \"1º trimestre 2012\", \"2º trim…\n$ trimestre_codigo                         &lt;dbl&gt; 201201, 201202, 201203, 20120…\n$ mil_pessoas_total                        &lt;dbl&gt; 1210, 1217, 1226, 1219, 1233,…\n$ mil_pessoas_forca_de_trabalho            &lt;dbl&gt; 765, 782, 784, 805, 796, 800,…\n$ mil_pessoas_forca_de_trabalho_ocupada    &lt;dbl&gt; 703, 733, 738, 762, 746, 761,…\n$ mil_pessoas_forca_de_trabalho_desocupada &lt;dbl&gt; 62, 49, 46, 42, 49, 39, 36, 3…\n$ mil_pessoas_fora_da_forca_de_trabalho    &lt;dbl&gt; 446, 434, 441, 415, 437, 443,…\n\n\n\nAs funções pivot_longer() e pivot_wider() são usadas para alternar entre dados ‘longos’ e ‘largos’. Normalmente, dados longos são mais fáceis de visualizar, enquanto dados largos são melhores para realizar cálculos comparativos entre categorias.",
    "crumbs": [
      "Materiais",
      "Transformando dados"
    ]
  },
  {
    "objectID": "05_transformacao.html#criando-e-transformando-variáveis",
    "href": "05_transformacao.html#criando-e-transformando-variáveis",
    "title": "Transformando dados",
    "section": "Criando e transformando variáveis",
    "text": "Criando e transformando variáveis\nPara criar novas variáveis, ou transformar variáveis que já existem, podemos usar a função mutate().\nAs variáveis uf_codigo e trimestre_codigo estão armazenadas como valores numéricos. No entanto, como não realizaremos operações matemáticas com esses valores, é mais apropriado transformá-los em fatores, o que facilita a análise e previne erros em cálculos futuros.\nExistem várias funções para transformar variáveis de um tipo para outro, como as.factor(), as.character(), as.numeric(), as.Date(), etc.\n\ndados_tipo &lt;- mutate(\n  # base de dados\n  dados_largos_renomeados,\n  # nova variável: \n  # nome_da_coluna = o que queremos calcular\n  uf_codigo = as.factor(uf_codigo),\n  trimestre_codigo = as.factor(trimestre_codigo)\n)\n\nPara calcular a taxa de desocupação, precisamos criar uma nova variável que represente a proporção de pessoas desocupadas em relação ao total de pessoas economicamente ativas.\n\ndados_com_proporcao &lt;- mutate(\n  # base de dados\n  dados_tipo,\n  # nova variável: \n  # nome_da_coluna = o que queremos calcular\n  prop_desocupacao = (mil_pessoas_forca_de_trabalho_desocupada / mil_pessoas_forca_de_trabalho)*100,\n)",
    "crumbs": [
      "Materiais",
      "Transformando dados"
    ]
  },
  {
    "objectID": "05_transformacao.html#ordenando-as-linhas",
    "href": "05_transformacao.html#ordenando-as-linhas",
    "title": "Transformando dados",
    "section": "Ordenando as linhas",
    "text": "Ordenando as linhas\nA base atual está ordada por trimestre e código da unidade da federação. Para facilitar a análise, podemos ordenar as linhas segundo a proporção de desocupação calculada no passo anterior, usando a função arrange():\n\narrange(\n  # base de dados\n  dados_com_proporcao,\n  # colunas que queremos usar ordenar\n  prop_desocupacao\n)\n\n# A tibble: 1,350 × 10\n   uf             uf_codigo trimestre         trimestre_codigo mil_pessoas_total\n   &lt;chr&gt;          &lt;fct&gt;     &lt;chr&gt;             &lt;fct&gt;                        &lt;dbl&gt;\n 1 Rondônia       11        3º trimestre 2023 202303                        1486\n 2 Rondônia       11        2º trimestre 2023 202302                        1483\n 3 Mato Grosso    51        3º trimestre 2023 202303                        2827\n 4 Santa Catarina 42        4º trimestre 2013 201304                        5371\n 5 Santa Catarina 42        4º trimestre 2012 201204                        5283\n 6 Santa Catarina 42        4º trimestre 2014 201404                        5478\n 7 Santa Catarina 42        2º trimestre 2014 201402                        5429\n 8 Santa Catarina 42        3º trimestre 2013 201303                        5343\n 9 Santa Catarina 42        3º trimestre 2014 201403                        5459\n10 Mato Grosso    51        2º trimestre 2023 202302                        2799\n# ℹ 1,340 more rows\n# ℹ 5 more variables: mil_pessoas_forca_de_trabalho &lt;dbl&gt;,\n#   mil_pessoas_forca_de_trabalho_ocupada &lt;dbl&gt;,\n#   mil_pessoas_forca_de_trabalho_desocupada &lt;dbl&gt;,\n#   mil_pessoas_fora_da_forca_de_trabalho &lt;dbl&gt;, prop_desocupacao &lt;dbl&gt;\n\n\nA função arrange() ordena, por padrão, de forma crescente. Podemos ordenar de forma decrescente, utilizando a função desc() junto à coluna que queremos ordenar de forma decrescente:\n\narrange(\n  # base de dados\n  dados_com_proporcao,\n  # colunas que queremos usar ordenar\n  desc(prop_desocupacao)\n)\n\n# A tibble: 1,350 × 10\n   uf         uf_codigo trimestre         trimestre_codigo mil_pessoas_total\n   &lt;chr&gt;      &lt;fct&gt;     &lt;chr&gt;             &lt;fct&gt;                        &lt;dbl&gt;\n 1 Pernambuco 26        2º trimestre 2021 202102                        7570\n 2 Amapá      16        2º trimestre 2018 201802                         602\n 3 Bahia      29        1º trimestre 2021 202101                       11965\n 4 Amapá      16        1º trimestre 2018 201801                         597\n 5 Pernambuco 26        1º trimestre 2021 202101                        7548\n 6 Bahia      29        3º trimestre 2020 202003                       11993\n 7 Sergipe    28        3º trimestre 2020 202003                        1835\n 8 Bahia      29        4º trimestre 2020 202004                       12004\n 9 Sergipe    28        1º trimestre 2021 202101                        1848\n10 Bahia      29        2º trimestre 2020 202002                       11870\n# ℹ 1,340 more rows\n# ℹ 5 more variables: mil_pessoas_forca_de_trabalho &lt;dbl&gt;,\n#   mil_pessoas_forca_de_trabalho_ocupada &lt;dbl&gt;,\n#   mil_pessoas_forca_de_trabalho_desocupada &lt;dbl&gt;,\n#   mil_pessoas_fora_da_forca_de_trabalho &lt;dbl&gt;, prop_desocupacao &lt;dbl&gt;\n\n\nNesse caso, as linhas ficaram ordenadas de forma decrescente, de acordo com a proporção de desocupação. Porém os trimestres não estão ordenados! A função arrange() permite que ordenemos por mais de uma coluna, e a ordem de prioridade é dada pela ordem em que as colunas são passadas para a função:\n\ndados_ordenados &lt;- arrange(\n  # base de dados\n  dados_com_proporcao,\n  # colunas que queremos usar ordenar\n  trimestre_codigo, desc(prop_desocupacao)\n)\n\nglimpse(dados_ordenados)\n\nRows: 1,350\nColumns: 10\n$ uf                                       &lt;chr&gt; \"Amapá\", \"Bahia\", \"Rio Grande…\n$ uf_codigo                                &lt;fct&gt; 16, 29, 24, 27, 13, 28, 25, 2…\n$ trimestre                                &lt;chr&gt; \"1º trimestre 2012\", \"1º trim…\n$ trimestre_codigo                         &lt;fct&gt; 201201, 201201, 201201, 20120…\n$ mil_pessoas_total                        &lt;dbl&gt; 487, 10986, 2540, 2383, 2463,…\n$ mil_pessoas_forca_de_trabalho            &lt;dbl&gt; 318, 6888, 1370, 1173, 1558, …\n$ mil_pessoas_forca_de_trabalho_ocupada    &lt;dbl&gt; 278, 6086, 1211, 1041, 1386, …\n$ mil_pessoas_forca_de_trabalho_desocupada &lt;dbl&gt; 40, 802, 159, 133, 173, 99, 1…\n$ mil_pessoas_fora_da_forca_de_trabalho    &lt;dbl&gt; 170, 4098, 1170, 1210, 905, 6…\n$ prop_desocupacao                         &lt;dbl&gt; 12.578616, 11.643438, 11.6058…\n\n\nAgora temos a base de dados ordenada por trimestre, e dentro de cada trimestre, por proporção de desocupação (de forma descrecente).",
    "crumbs": [
      "Materiais",
      "Transformando dados"
    ]
  },
  {
    "objectID": "05_transformacao.html#pipe---encadeando-funções",
    "href": "05_transformacao.html#pipe---encadeando-funções",
    "title": "Transformando dados",
    "section": "Pipe - Encadeando funções",
    "text": "Pipe - Encadeando funções\nNos exemplos anteriores, utilizamos uma função por vez, para facilitar a compreensão de cada etapa. No entanto, à medida que nos familiarizamos com as funções, podemos encadear várias delas em um único fluxo de código usando o operador pipe (%&gt;% ou |&gt;). Isso torna o código mais conciso e elimina a criação de objetos intermediários desnecessários.\nPodemos reescrever os códigos anteriores, usando o operador pipe para encadear as funções. Isso permite que criemos menos objetos intermediários (como os que criamos anteriormente: dados_renomeados, dados_filtrados, dados_selecionados, etc.). Porém, é importante ter cuidado para não criar sequências muito longas e difíceis de entender.\nNo exemplo abaixo, criamos menos objetos intermediários, e encadeamos as funções usadas anteriormente usando o pipe:\n\ndados_filtrados_selecionados &lt;- dados_brutos |&gt;\n  # limpando os nomes das colunas\n  clean_names() |&gt;\n  # filtrando as linhas\n  filter(variavel == \"Pessoas de 14 anos ou mais de idade\") |&gt;\n  # selecionando as colunas\n  select(\n    unidade_da_federacao,\n    unidade_da_federacao_codigo,\n    trimestre,\n    trimestre_codigo,\n    condicao_em_relacao_a_forca_de_trabalho_e_condicao_de_ocupacao,\n    valor\n  ) |&gt;\n  # renomeando as colunas\n  rename(\n    condicao = condicao_em_relacao_a_forca_de_trabalho_e_condicao_de_ocupacao,\n    valor_mil_pessoas = valor,\n    uf = unidade_da_federacao,\n    uf_codigo = unidade_da_federacao_codigo\n  )\n\ndados_largos &lt;- dados_filtrados_selecionados |&gt;\n  # transformando para formato largo\n  pivot_wider(\n    names_from = condicao,\n    values_from = valor_mil_pessoas,\n    names_prefix = \"mil_pessoas_\"\n  ) |&gt;\n  # limpando o nome das colunas novamente\n  clean_names()\n\n  \n  \ndados_preparados &lt;- dados_largos |&gt;  \n  # transformando as variáveis \n  mutate(\n    uf_codigo = as.factor(uf_codigo),\n    trimestre_codigo = as.factor(trimestre_codigo),\n    prop_desocupacao = (\n      mil_pessoas_forca_de_trabalho_desocupada / mil_pessoas_forca_de_trabalho\n    ) * 100,\n  ) |&gt;\n  # ordenando a base de dados\n  arrange(trimestre_codigo, desc(prop_desocupacao))\n\n\nglimpse(dados_preparados)\n\nRows: 1,350\nColumns: 10\n$ uf                                       &lt;chr&gt; \"Amapá\", \"Bahia\", \"Rio Grande…\n$ uf_codigo                                &lt;fct&gt; 16, 29, 24, 27, 13, 28, 25, 2…\n$ trimestre                                &lt;chr&gt; \"1º trimestre 2012\", \"1º trim…\n$ trimestre_codigo                         &lt;fct&gt; 201201, 201201, 201201, 20120…\n$ mil_pessoas_total                        &lt;dbl&gt; 487, 10986, 2540, 2383, 2463,…\n$ mil_pessoas_forca_de_trabalho            &lt;dbl&gt; 318, 6888, 1370, 1173, 1558, …\n$ mil_pessoas_forca_de_trabalho_ocupada    &lt;dbl&gt; 278, 6086, 1211, 1041, 1386, …\n$ mil_pessoas_forca_de_trabalho_desocupada &lt;dbl&gt; 40, 802, 159, 133, 173, 99, 1…\n$ mil_pessoas_fora_da_forca_de_trabalho    &lt;dbl&gt; 170, 4098, 1170, 1210, 905, 6…\n$ prop_desocupacao                         &lt;dbl&gt; 12.578616, 11.643438, 11.6058…",
    "crumbs": [
      "Materiais",
      "Transformando dados"
    ]
  },
  {
    "objectID": "05_transformacao.html#unindo-duas-bases-de-dados",
    "href": "05_transformacao.html#unindo-duas-bases-de-dados",
    "title": "Transformando dados",
    "section": "Unindo duas bases de dados",
    "text": "Unindo duas bases de dados\nUnir duas tabelas é algo comum em análises de dados. Podemos usar algumas funções para combinar duas tabelas, utilizando uma ou mais colunas como “chave”.\nO pacote dplyr apresenta um conjunto de funções para realizar diferentes tipos de uniões, como left_join(), inner_join(), full_join(), anti_join(), entre outras.\nA função left_join() é a mais frequentemente usada: ela mantém todas as linhas da primeira tabela e adiciona colunas da segunda tabela onde houver correspondência.\nUm exemplo comum de uso é quando temos dados por município ou estado, e desejamos visualizar esses dados em um mapa. Para isso, precisamos de informações geoespaciais, como a delimitação geográfica de cada município ou estado. Podemos usar o left_join() para combinar esses dados geoespaciais com os dados que queremos visualizar.\nVamos usar o pacote geobr para carregar as geometrias dos estados brasileiros.\n\n\n\n\n\n\nO pacote geobr facilita o acesso a dados geoespaciais do Brasil, como estados, municípios e outras divisões administrativas. Ele é muito útil quando queremos fazer análises geoespaciais, já que oferece dados geográficos prontos para uso.\nPodemos utilizar a função read_state() para carregar as geometrias dos estados brasileiros. Isso nos permite combinar essas geometrias com outros dados, como taxas de desocupação, e criar mapas que facilitam a visualização de padrões regionais.\n\n\n\n\nlibrary(geobr)\ngeo_estados &lt;- read_state(showProgress = FALSE)\nglimpse(geo_estados)\n\nRows: 27\nColumns: 6\n$ code_state   &lt;dbl&gt; 11, 12, 13, 14, 15, 16, 17, 21, 22, 23, 24, 25, 26, 27, 2…\n$ abbrev_state &lt;chr&gt; \"RO\", \"AC\", \"AM\", \"RR\", \"PA\", \"AP\", \"TO\", \"MA\", \"PI\", \"CE…\n$ name_state   &lt;chr&gt; \"Rondônia\", \"Acre\", \"Amazonas\", \"Roraima\", \"Pará\", \"Amapá…\n$ code_region  &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, …\n$ name_region  &lt;chr&gt; \"Norte\", \"Norte\", \"Norte\", \"Norte\", \"Norte\", \"Norte\", \"No…\n$ geom         &lt;MULTIPOLYGON [°]&gt; MULTIPOLYGON (((-63.32721 -..., MULTIPOLYGON…\n\n\nO left_join() é usado aqui para combinar os dados do SIDRA com os dados das delimitações das UFs. Cada linha do nosso dataset de desocupação será associada à respectiva geometria da UF, permitindo visualizarmos as proporções de desocupação por UF em um mapa. Esse tipo de operação é comum quando queremos identificar padrões regionais.\nÉ importante garantir que as colunas usadas na combinação de tabelas (o argumento by do left_join()) tenham o mesmo tipo de dado. Podemos verificar o tipo de dado de cada coluna com a função class():\n\nclass(geo_estados$code_state)\n\n[1] \"numeric\"\n\nclass(dados_ordenados$uf_codigo)\n\n[1] \"factor\"\n\n\nNeste caso, as colunas que queremos usar como chave são de tipos diferentes (numérico e fator), O left_join() não conseguirá fazer a correspondência corretamente, e a função gerará um erro:\n\nleft_join(geo_estados, dados_ordenados, by = c(\"code_state\" = \"uf_codigo\"))\n\nError in `sf_column %in% names(g)`:\n! Can't join `x$code_state` with `y$uf_codigo` due to incompatible\n  types.\nℹ `x$code_state` is a &lt;double&gt;.\nℹ `y$uf_codigo` is a &lt;factor&lt;48524&gt;&gt;.\n\n\nNo exemplo, podemos transformar a coluna code_state em fator usando mutate(). Assim, garantimos que as colunas usadas no argumento by sejam do mesmo tipo e possam ser corretamente combinados.\n\ndados_geo &lt;- geo_estados |&gt; \n  mutate(code_state = as.factor(code_state)) |&gt; \n  left_join(dados_ordenados, by = c(\"code_state\" = \"uf_codigo\"))\n\nglimpse(dados_geo)\n\nRows: 1,350\nColumns: 15\n$ code_state                               &lt;fct&gt; 11, 11, 11, 11, 11, 11, 11, 1…\n$ abbrev_state                             &lt;chr&gt; \"RO\", \"RO\", \"RO\", \"RO\", \"RO\",…\n$ name_state                               &lt;chr&gt; \"Rondônia\", \"Rondônia\", \"Rond…\n$ code_region                              &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,…\n$ name_region                              &lt;chr&gt; \"Norte\", \"Norte\", \"Norte\", \"N…\n$ uf                                       &lt;chr&gt; \"Rondônia\", \"Rondônia\", \"Rond…\n$ trimestre                                &lt;chr&gt; \"1º trimestre 2012\", \"2º trim…\n$ trimestre_codigo                         &lt;fct&gt; 201201, 201202, 201203, 20120…\n$ mil_pessoas_total                        &lt;dbl&gt; 1210, 1217, 1226, 1219, 1233,…\n$ mil_pessoas_forca_de_trabalho            &lt;dbl&gt; 765, 782, 784, 805, 796, 800,…\n$ mil_pessoas_forca_de_trabalho_ocupada    &lt;dbl&gt; 703, 733, 738, 762, 746, 761,…\n$ mil_pessoas_forca_de_trabalho_desocupada &lt;dbl&gt; 62, 49, 46, 42, 49, 39, 36, 3…\n$ mil_pessoas_fora_da_forca_de_trabalho    &lt;dbl&gt; 446, 434, 441, 415, 437, 443,…\n$ prop_desocupacao                         &lt;dbl&gt; 8.104575, 6.265985, 5.867347,…\n$ geom                                     &lt;MULTIPOLYGON [°]&gt; MULTIPOLYGON (((…\n\n\nAgora temos uma base de dados que combina os dados do SIDRA com as geometrias dos estados brasileiros.\nCombinar dados dessa forma nos permite fazer visualizações geoespaciais, como um mapa de calor das taxas de desocupação por estado. Isso facilita a identificação de padrões regionais, ajudando na interpretação dos dados.\nNão falaremos nesse momento sobre como criar visualizações e mapas, pois isso será abordado em aulas futuras. Mas podemos adiantar um exemplo de como criar um mapa apresentando as proporções de desocupação por estado:\n\nCódigodados_geo |&gt; \n  filter(trimestre_codigo == \"202402\") |&gt;\n  ggplot() +\n  geom_sf(aes(fill = prop_desocupacao)) +\n  theme_light() +\n  scale_fill_viridis_c() +\n  labs(title = \"Proporção de desocupação por UF no 2º trimestre de 2024\",\n       fill = \"Proporção de desocupação (%)\") +\n  theme(legend.position = \"bottom\")",
    "crumbs": [
      "Materiais",
      "Transformando dados"
    ]
  },
  {
    "objectID": "05_transformacao.html#sugestões-de-materiais",
    "href": "05_transformacao.html#sugestões-de-materiais",
    "title": "Transformando dados",
    "section": "Sugestões de materiais",
    "text": "Sugestões de materiais\n\nLivro R para Ciência de Dados 2ed:\n\nTransformação de dados\nOrganização de dados",
    "crumbs": [
      "Materiais",
      "Transformando dados"
    ]
  },
  {
    "objectID": "04_conhecendo.html",
    "href": "04_conhecendo.html",
    "title": "Conhecendo a base de dados",
    "section": "",
    "text": "Conceitos prévios importantes:\n\nComo importar bases de dados?\nTipos de variáveis\nValores faltantes\nNesta seção, vamos conhecer algumas funções que nos ajudarão a conhecer um pouco mais sobre a base de dados que estamos trabalhando.\nEssa etapa é importante para:\nVamos começar importando a base de dados que utilizaremos:\nlibrary(tidyverse)\ndados &lt;- read_csv2(\"dados/sidrar_4092_bruto_2.csv\")",
    "crumbs": [
      "Materiais",
      "Conhecendo a base de dados"
    ]
  },
  {
    "objectID": "04_conhecendo.html#estrutura-da-base-de-dados",
    "href": "04_conhecendo.html#estrutura-da-base-de-dados",
    "title": "Conhecendo a base de dados",
    "section": "Estrutura da base de dados",
    "text": "Estrutura da base de dados\nVamos começar conhecendo a estrutura da base de dados. Para isso, existem algumas funções para saber o número de colunas e linhas, os nomes das colunas, entre outras informações. Algumas delas apresentam as mesmas informações, mas de formas diferentes.\n\n# Número de colunas\nncol(dados)\n\n[1] 13\n\n# Número de linhas\nnrow(dados)\n\n[1] 27000\n\n# Número de linhas e colunas\ndim(dados)\n\n[1] 27000    13\n\n# Nomes das colunas\nnames(dados)\n\n [1] \"Nível Territorial (Código)\"                                             \n [2] \"Nível Territorial\"                                                      \n [3] \"Unidade de Medida (Código)\"                                             \n [4] \"Unidade de Medida\"                                                      \n [5] \"Valor\"                                                                  \n [6] \"Unidade da Federação (Código)\"                                          \n [7] \"Unidade da Federação\"                                                   \n [8] \"Trimestre (Código)\"                                                     \n [9] \"Trimestre\"                                                              \n[10] \"Variável (Código)\"                                                      \n[11] \"Variável\"                                                               \n[12] \"Condição em relação à força de trabalho e condição de ocupação (Código)\"\n[13] \"Condição em relação à força de trabalho e condição de ocupação\"         \n\n\nA função glimpse() do pacote dplyr apresenta informações como: número de linhas, número de colunas, nome e tipo de cada coluna, e os primeiros valores de cada coluna. Porém o texto resultante dependerá da largura do Console:\n\nglimpse(dados)\n\n\n\nCaptura de tela: Resultado da função glimpse()\n\nView\nUma outra função que é interessante é a View(). Ela nos permite visualizar a base de dados em uma nova janela, em formato de tabela. Porém, é importante tomar cuidado ao usá-la com bases de dados grandes, pois pode travar o RStudio dependendo.\nOutra forma de acessar o View é clicando na linha do objeto no painel Environment do RStudio:\n\n\nCaptura de tela: Onde clicamos para abrir o View\n\n\nView(dados)\n\n\n\nGravação da tela - Usando o View",
    "crumbs": [
      "Materiais",
      "Conhecendo a base de dados"
    ]
  },
  {
    "objectID": "04_conhecendo.html#sumário-das-variáveis",
    "href": "04_conhecendo.html#sumário-das-variáveis",
    "title": "Conhecendo a base de dados",
    "section": "Sumário das variáveis",
    "text": "Sumário das variáveis\nEm funções apresentadas anteriormente, como a names(), já conseguimos ter uma ideia de quais são as variáveis da base de dados. Mas é interessante ter mais informações, como: tipo de variável, quantidade de valores faltantes, entre outros.\nNessa etapa, conheceremos algumas funções que nos ajudarão a ter essas informações. Algumas apresentam as mesmas informações, mas de formas diferentes. Portanto, é interessante conhecer algumas delas, e escolher qual é a que melhor atende às nossas necessidades.\n\n\n\n\n\n\nAviso\n\n\n\nCuidado: as funções apresentadas a seguir calculam algumas estatísticas descritivas (como a média, mediana, desvio padrão, valor mínimo, valor máximo, entre outras) em variáveis numéricas. Porém, ainda não “arrumamos” a base de dados (faremos isso no capítulo Transformando dados), e os dados ainda não estão adequados para esses cálculos.\nAlguns exemplos:\n\nVárias colunas numéricas representam o código de uma categoria, e não faz sentido calcular a média desses códigos.\nA variável valor está relacionada com a variável unidade_de_medida. Neste momento, a tabela apresenta valores com diferentes unidades de medida, e não faz sentido calcular a média desses valores.\n\n\nunique(dados$`Unidade de Medida`)\n\n[1] \"Mil pessoas\" \"%\"          \n\n\nFalaremos sobre o cálculo de estatísticas descritivas no capítulo Analisando dados.\n\n\nsummary()\nA função summary() é uma função do R base (ou seja, não precisamos carregar nenhum pacote para usá-la), e ela nos dá um sumário das variáveis da base de dados.\n\nsummary(dados)\n\n Nível Territorial (Código) Nível Territorial  Unidade de Medida (Código)\n Min.   :3                  Length:27000       Min.   :   2.0            \n 1st Qu.:3                  Class :character   1st Qu.:   2.0            \n Median :3                  Mode  :character   Median :   2.0            \n Mean   :3                                     Mean   : 394.5            \n 3rd Qu.:3                                     3rd Qu.: 394.5            \n Max.   :3                                     Max.   :1572.0            \n                                                                         \n Unidade de Medida      Valor         Unidade da Federação (Código)\n Length:27000       Min.   :    0.3   Min.   :11.00                \n Class :character   1st Qu.:    1.5   1st Qu.:17.00                \n Mode  :character   Median :    7.8   Median :27.00                \n                    Mean   :  862.0   Mean   :29.11                \n                    3rd Qu.:  105.8   3rd Qu.:41.00                \n                    Max.   :39480.0   Max.   :53.00                \n                    NA's   :1350                                   \n Unidade da Federação Trimestre (Código)  Trimestre         Variável (Código)\n Length:27000         Min.   :201201     Length:27000       Min.   :1641     \n Class :character     1st Qu.:201501     Class :character   1st Qu.:3476     \n Mode  :character     Median :201802     Mode  :character   Median :4096     \n                      Mean   :201778                        Mean   :3484     \n                      3rd Qu.:202102                        3rd Qu.:4104     \n                      Max.   :202402                        Max.   :4105     \n                                                                             \n   Variável        \n Length:27000      \n Class :character  \n Mode  :character  \n                   \n                   \n                   \n                   \n Condição em relação à força de trabalho e condição de ocupação (Código)\n Min.   :32385                                                          \n 1st Qu.:32386                                                          \n Median :32387                                                          \n Mean   :32410                                                          \n 3rd Qu.:32446                                                          \n Max.   :32447                                                          \n                                                                        \n Condição em relação à força de trabalho e condição de ocupação\n Length:27000                                                  \n Class :character                                              \n Mode  :character                                              \n                                                               \n                                                               \n                                                               \n                                                               \n\n\nskimr::skim()\nO pacote skimr tem uma função chamada skim() que nos dá um sumário das variáveis da base de dados.\nÉ interesante salvar o resultado da função em um objeto, para que possamos acessar as informações posteriormente, em formato de tabela.\n\nlibrary(skimr)\nskim_dados &lt;- skim(dados)\n\nO resultado da função skim() é dividido em duas partes:\n\nData summary: informações gerais sobre a base de dados, como: nome do objeto, número de linhas, número de colunas, quantas colunas temos em cada tipo, e se a base está agrupada por alguma variável1.\n\nVariable type: para cada tipo de variável presente na base de dados, temos informações como:\n\n\nskim_variable: nome da variável.\n\nn_missing: número de valores faltantes.\n\ncomplete_rate: proporção de valores não faltantes (está relacionada com a n_missing).\nOutras colunas específicas segundo o tipo de variável.\n\n\n\nA seguir, estão as informações que a função skim() retorna para os tipos de variáveis mais frequentes:\n\n\ncharacter (dados de texto):\n\n\nmin: número mínimo de caracteres.\n\nmax: número máximo de caracteres.\n\nempty: número de linhas contendo valores vazios (um valor vazio é um valor que contém apenas \"\").\n\nn_unique: número de valores únicos.\n\nwhitespace: número de linhas contendo apenas espaços em branco.\n\n\n\nnumeric (dados numéricos):\n\n\nmean: média.\n\nsd: desvio padrão.\n\np0: valor mínimo.\n\np25: primeiro quartil.\n\np50: mediana.\n\np75: terceiro quartil.\n\np100: valor máximo.\n\nhist: histograma dos valores.\n\n\n\ndate (datas):\n\n\nmin: data mínima.\n\nmax: data máxima.\n\nmedian: data mediana.\n\nn_unique: número de datas únicas.\n\n\n\nfactor (dados categóricos):\n\n\nordered: os níveis do fator estão ordenados?\n\nn_unique: número de valores únicos do fator.\n\ntop_counts: os valores mais frequentes do fator.\n\n\n\nlogical (dados booleanos):\n\n\nmean: média dos valores, considerando que TRUE é 1 e FALSE é 0.\n\ncount: contagem dos valores TRUE e FALSE.\n\n\n\nA seguir, podemos ver o resultado da função skim():\n\nskim_dados\n\n\nData summary\n\n\nName\ndados\n\n\nNumber of rows\n27000\n\n\nNumber of columns\n13\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\ncharacter\n6\n\n\nnumeric\n7\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: character\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmin\nmax\nempty\nn_unique\nwhitespace\n\n\n\nNível Territorial\n0\n1\n20\n20\n0\n1\n0\n\n\nUnidade de Medida\n0\n1\n1\n11\n0\n2\n0\n\n\nUnidade da Federação\n0\n1\n4\n19\n0\n27\n0\n\n\nTrimestre\n0\n1\n17\n17\n0\n50\n0\n\n\nVariável\n0\n1\n35\n89\n0\n4\n0\n\n\nCondição em relação à força de trabalho e condição de ocupação\n0\n1\n5\n30\n0\n5\n0\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nhist\n\n\n\nNível Territorial (Código)\n0\n1.00\n3.00\n0.00\n3.0\n3.0\n3.0\n3.00\n3\n▁▁▇▁▁\n\n\nUnidade de Medida (Código)\n0\n1.00\n394.50\n679.84\n2.0\n2.0\n2.0\n394.50\n1572\n▇▁▁▁▂\n\n\nValor\n1350\n0.95\n862.03\n2896.64\n0.3\n1.5\n7.8\n105.75\n39480\n▇▁▁▁▁\n\n\nUnidade da Federação (Código)\n0\n1.00\n29.11\n12.78\n11.0\n17.0\n27.0\n41.00\n53\n▇▇▇▃▅\n\n\nTrimestre (Código)\n0\n1.00\n201778.46\n361.36\n201201.0\n201501.0\n201801.5\n202102.00\n202402\n▇▅▇▅▇\n\n\nVariável (Código)\n0\n1.00\n3484.25\n1064.24\n1641.0\n3475.5\n4095.5\n4104.25\n4105\n▂▁▁▁▇\n\n\nCondição em relação à força de trabalho e condição de ocupação (Código)\n0\n1.00\n32410.20\n29.65\n32385.0\n32386.0\n32387.0\n32446.00\n32447\n▇▁▁▁▅",
    "crumbs": [
      "Materiais",
      "Conhecendo a base de dados"
    ]
  },
  {
    "objectID": "04_conhecendo.html#valores-faltantes-na",
    "href": "04_conhecendo.html#valores-faltantes-na",
    "title": "Conhecendo a base de dados",
    "section": "Valores faltantes (NA)",
    "text": "Valores faltantes (NA)\nA presença de valores faltantes é algo comum em bases de dados. Eles podem ocorrer por diversos motivos, como: não temos a informação, erros de digitação, entre outros.\nÉ importante identificar onde estão esses valores, para que possamos nos atentar em análises futuras.\nExistem algumas funções que nos ajudam a identificar a presença de valores faltantes na base de dados. O pacote naniar apresenta funções úteis para isso: a função gg_miss_var() cria uma visualição apresentando o nome das variáveis da base de dados, assim como a quantidade de valores faltantes em cada uma delas.\n\nlibrary(naniar)\n# Valores absolutos\ngg_miss_var(dados)\n\n\n\n\n\n\n# Valores relativos\ngg_miss_var(dados, show_pct = TRUE)",
    "crumbs": [
      "Materiais",
      "Conhecendo a base de dados"
    ]
  },
  {
    "objectID": "04_conhecendo.html#section",
    "href": "04_conhecendo.html#section",
    "title": "Conhecendo a base de dados",
    "section": "",
    "text": "Em situações onde trabalharmos com dados que possuem um número de linhas muito grande, não podemos utilizar a função View() para ver a tabela inteira.\nNesse caso, podemos ser interessante usar funções que retornam apenas algumas linhas da base de dados, como head(), tail(), slice_sample(), entre outras.\nAntes de usá-las, vamos adicionar uma coluna que represente o número da linha, para que seja mais fácil identificar as linhas que estamos selecionando:\n\ndados_com_n_linha &lt;- rowid_to_column(dados, \"n_linha\")\n\nAgora podemos usar as funções para retornar algumas linhas da base de dados. Observe os resultados apresentados, e os valores na coluna n_linha:\n\n# Exibindo as primeiras linhas\nhead(dados_com_n_linha)\n\n# A tibble: 6 × 14\n  n_linha Nível Territorial (Código…¹ `Nível Territorial` Unidade de Medida (C…²\n    &lt;int&gt;                       &lt;dbl&gt; &lt;chr&gt;                                &lt;dbl&gt;\n1       1                           3 Unidade da Federaç…                   1572\n2       2                           3 Unidade da Federaç…                   1572\n3       3                           3 Unidade da Federaç…                   1572\n4       4                           3 Unidade da Federaç…                   1572\n5       5                           3 Unidade da Federaç…                   1572\n6       6                           3 Unidade da Federaç…                      2\n# ℹ abbreviated names: ¹​`Nível Territorial (Código)`,\n#   ²​`Unidade de Medida (Código)`\n# ℹ 10 more variables: `Unidade de Medida` &lt;chr&gt;, Valor &lt;dbl&gt;,\n#   `Unidade da Federação (Código)` &lt;dbl&gt;, `Unidade da Federação` &lt;chr&gt;,\n#   `Trimestre (Código)` &lt;dbl&gt;, Trimestre &lt;chr&gt;, `Variável (Código)` &lt;dbl&gt;,\n#   Variável &lt;chr&gt;,\n#   `Condição em relação à força de trabalho e condição de ocupação (Código)` &lt;dbl&gt;, …\n\n# Exibindo as últimas linhas\ntail(dados_com_n_linha)\n\n# A tibble: 6 × 14\n  n_linha Nível Territorial (Código…¹ `Nível Territorial` Unidade de Medida (C…²\n    &lt;int&gt;                       &lt;dbl&gt; &lt;chr&gt;                                &lt;dbl&gt;\n1   26995                           3 Unidade da Federaç…                      2\n2   26996                           3 Unidade da Federaç…                      2\n3   26997                           3 Unidade da Federaç…                      2\n4   26998                           3 Unidade da Federaç…                      2\n5   26999                           3 Unidade da Federaç…                      2\n6   27000                           3 Unidade da Federaç…                      2\n# ℹ abbreviated names: ¹​`Nível Territorial (Código)`,\n#   ²​`Unidade de Medida (Código)`\n# ℹ 10 more variables: `Unidade de Medida` &lt;chr&gt;, Valor &lt;dbl&gt;,\n#   `Unidade da Federação (Código)` &lt;dbl&gt;, `Unidade da Federação` &lt;chr&gt;,\n#   `Trimestre (Código)` &lt;dbl&gt;, Trimestre &lt;chr&gt;, `Variável (Código)` &lt;dbl&gt;,\n#   Variável &lt;chr&gt;,\n#   `Condição em relação à força de trabalho e condição de ocupação (Código)` &lt;dbl&gt;, …\n\n# \"Sorteando\" linhas\nslice_sample(dados_com_n_linha, n = 5)\n\n# A tibble: 5 × 14\n  n_linha Nível Territorial (Código…¹ `Nível Territorial` Unidade de Medida (C…²\n    &lt;int&gt;                       &lt;dbl&gt; &lt;chr&gt;                                &lt;dbl&gt;\n1   15294                           3 Unidade da Federaç…                      2\n2   16037                           3 Unidade da Federaç…                      2\n3   14364                           3 Unidade da Federaç…                   1572\n4   11004                           3 Unidade da Federaç…                   1572\n5   16360                           3 Unidade da Federaç…                      2\n# ℹ abbreviated names: ¹​`Nível Territorial (Código)`,\n#   ²​`Unidade de Medida (Código)`\n# ℹ 10 more variables: `Unidade de Medida` &lt;chr&gt;, Valor &lt;dbl&gt;,\n#   `Unidade da Federação (Código)` &lt;dbl&gt;, `Unidade da Federação` &lt;chr&gt;,\n#   `Trimestre (Código)` &lt;dbl&gt;, Trimestre &lt;chr&gt;, `Variável (Código)` &lt;dbl&gt;,\n#   Variável &lt;chr&gt;,\n#   `Condição em relação à força de trabalho e condição de ocupação (Código)` &lt;dbl&gt;, …",
    "crumbs": [
      "Materiais",
      "Conhecendo a base de dados"
    ]
  },
  {
    "objectID": "04_conhecendo.html#conhecendo-os-valores-únicos-de-uma-coluna",
    "href": "04_conhecendo.html#conhecendo-os-valores-únicos-de-uma-coluna",
    "title": "Conhecendo a base de dados",
    "section": "Conhecendo os valores únicos de uma coluna",
    "text": "Conhecendo os valores únicos de uma coluna\nPara variáveis categóricas ou de texto, é interessante conhecer os valores únicos presentes.\nPara acessar uma coluna específica, utilize o $. Elas retornarão como vetores, e poderemos usar as funções que já conhecemos. Ex: dados$ano.\nDica: após escrever o nome_do_dataframe$, aperte tab para que o RStudio faça sugestões de colunas da base.\nA função unique() retorna os valores únicos de um vetor. Exemplo:\n\nunique(dados$`Unidade de Medida`)\n\n[1] \"Mil pessoas\" \"%\"",
    "crumbs": [
      "Materiais",
      "Conhecendo a base de dados"
    ]
  },
  {
    "objectID": "04_conhecendo.html#footnotes",
    "href": "04_conhecendo.html#footnotes",
    "title": "Conhecendo a base de dados",
    "section": "Notas de rodapé",
    "text": "Notas de rodapé\n\nAinda não abordamos o conceito de grupos, então isso ficará mais claro posteriormente.↩︎",
    "crumbs": [
      "Materiais",
      "Conhecendo a base de dados"
    ]
  },
  {
    "objectID": "20_ipeadatalake.html",
    "href": "20_ipeadatalake.html",
    "title": "Infraestrutura de pesquisa do Ipea",
    "section": "",
    "text": "Aviso\n\n\n\nPágina em construção! Em breve.",
    "crumbs": [
      "Data Lake do Ipea",
      "Infraestrutura de pesquisa do Ipea"
    ]
  },
  {
    "objectID": "00_instrucoes_pre_curso.html",
    "href": "00_instrucoes_pre_curso.html",
    "title": "Instalação",
    "section": "",
    "text": "Importante\n\n\n\nRecomendamos que todas as pessoas participantes instalem o R e o RStudio antes do início do curso.\nCaso tenha alguma dificuldade, entre em contato com a equipe do curso o quanto antes.",
    "crumbs": [
      "Pré-curso",
      "Instalação"
    ]
  },
  {
    "objectID": "00_instrucoes_pre_curso.html#instalação-do-r-e-rstudio",
    "href": "00_instrucoes_pre_curso.html#instalação-do-r-e-rstudio",
    "title": "Instalação",
    "section": "Instalação do R e RStudio",
    "text": "Instalação do R e RStudio\nPara a utilização do R, é necessário instalar o software R e o RStudio. O R é a linguagem de programação e o RStudio é um ambiente de desenvolvimento integrado (IDE - Integrated Development Environment) que facilita a utilização do R.\n\n\n\n\n\n\nAviso\n\n\n\nAtenção: O R deve ser instalado antes do RStudio.\n\n\nInstalação do R\nPara instalar o R, acesse o site CRAN e escolha o link de download de acordo com o seu sistema operacional:\n\n\nCaptura de tela do site CRAN\n\nInstale o R utilizando o instalador baixado.\nInstalação do RStudio\nApós instalar o R, acesse o site RStudio Desktop e escolha o link de download de acordo com o seu sistema operacional:\n\n\nCaptura de tela do site RStudio Desktop\n\nInstale o RStudio utilizando o instalador baixado.\nVerificação da instalação\nPara verificar se a instalação foi realizada com sucesso, abra o RStudio. Para isso, procure o ícone do RStudio no menu de programas do seu sistema operacional.\nA tela inicial do RStudio é semelhante à imagem abaixo:\n\n\nCaptura de tela da IDE RStudio\n\nVerificação da versão do R\nO R possui versões, e é importante verificar se a versão instalada é recente.\n\n\n\n\n\n\nAviso\n\n\n\nRecomendamos que utilizem o R na versão 4.1.0 ou superior.\nCaso a versão do R seja inferior a 4.1.0, recomendamos que atualizem o R para a versão mais recente.\nVersões mais antigas podem ter incompatibilidades com alguns códigos que utilizaremos durante o curso.\n\n\nExiste mais de uma forma para verificar a versão do R. A forma mais simples é verificando o texto que aparece no painel “Console” ao abrir o RStudio:\n\n\nCaptura de tela da IDE RStudio\n\nOutra forma é utilizando o comando R.version.string. Para isso, execute o seguinte comando no console do RStudio. Por exemplo, a versão do R utilizada para a elaboração deste material é 4.4.1:\nO comando R.version retorna um objeto com diversas informações sobre a versão do R, o sistema operacional utilizado, etc:\n\nR.version\n\n               _                           \nplatform       aarch64-apple-darwin20      \narch           aarch64                     \nos             darwin20                    \nsystem         aarch64, darwin20           \nstatus                                     \nmajor          4                           \nminor          4.1                         \nyear           2024                        \nmonth          06                          \nday            14                          \nsvn rev        86737                       \nlanguage       R                           \nversion.string R version 4.4.1 (2024-06-14)\nnickname       Race for Your Life",
    "crumbs": [
      "Pré-curso",
      "Instalação"
    ]
  },
  {
    "objectID": "01_r_rstudio.html",
    "href": "01_r_rstudio.html",
    "title": "Conhecendo o R e o RStudio",
    "section": "",
    "text": "Aviso\n\n\n\nPágina em construção! Em breve.",
    "crumbs": [
      "Materiais",
      "Conhecendo o R e o RStudio"
    ]
  },
  {
    "objectID": "01_r_rstudio.html#sugestões-de-materiais",
    "href": "01_r_rstudio.html#sugestões-de-materiais",
    "title": "Conhecendo o R e o RStudio",
    "section": "Sugestões de materiais",
    "text": "Sugestões de materiais\n\nLivro R para Ciência de Dados 2ed:\n\nFluxo de Trabalho: básico\nFluxo de Trabalho: scripts\nFluxo de Trabalho: obtendo ajuda",
    "crumbs": [
      "Materiais",
      "Conhecendo o R e o RStudio"
    ]
  }
]