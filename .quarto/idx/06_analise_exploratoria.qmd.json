{"title":"Análise exploratória de dados","markdown":{"yaml":{"title":"Análise exploratória de dados","code-annotations":"hover"},"headingText":"Importando dados","containsRefs":false,"markdown":"\n\nNesta aula:\n\n- Conheceremos funções para calcular estatísticas descritivas, como média, mediana, variância, desvio padrão, entre outras. \n\n- Discutiremos como agrupar dados e calcular estatísticas descritivas para cada grupo.\n\n- Aprenderemos a elaborar tabelas de frequência.\n\nUma etapa importante da análise exploratória de dados envolve visualizar dados. Isso será apresentado na próxima aula!\n\n\nNesta aula, utilizaremos a tabela preparada na [aula anterior](05_transformacao): `\"dados_output/sidra_4092_arrumado.rds\"`.\n\n::: {.callout-important collapse=\"true\"}\n### Expanda para fazer download da base de dados\n\nCaso não tenha o arquivo da tabela que utilizaremos, você pode baixar [aqui](https://github.com/ipeadata-lab/curso_r_intro_202409/raw/refs/heads/main/dados_output/sidra_4092_arrumado.rds), e copiar o arquivo para a pasta `dados_output` do seu projeto.\n\nOutra opção é executar o código abaixo:\n\n```{r}\n#| eval: false\ndownload.file(\n  url = \"https://github.com/ipeadata-lab/curso_r_intro_202409/raw/refs/heads/main/dados_output/sidra_4092_arrumado.rds\",  # <1>\n  destfile = \"dados_output/sidra_4092_arrumado.rds\", # <2>\n  mode = \"wb\" # <3>\n  )\n```\n\n1.  URL que desejamos baixar\n2.  Caminho onde queremos baixar o arquivo (diretório + nome do arquivo + extensão do arquivo)\n3.  Configuração que evita corromper arquivos binários.\n:::\n\nVamos carregar a base de dados com a função `read_rds()`:\n\n```{r}\n#| message: false\nlibrary(dplyr) # <1>\ndados <- readr::read_rds(\"dados_output/sidra_4092_arrumado.rds\") # <2>\nglimpse(dados) # <3>\n```\n1. Carregando o pacote dplyr\n2. Importando os dados\n3. Espiando a tabela\n\n\n\n\n## Estatísticas descritivas\n\n\nNa aula [conhecendo os dados](04_conhecendo.qmd), vimos algumas funções que são interessantes para ver estatísticas descritivas de todas as variáveis de uma vez, como a `summary()` e a `skim()`.\n\nPodemos utilizar também funções do R para calcular estatísticas descritivas de uma variável.\n\nPor exemplo, para calcular a média da variável `perc_desocupacao`, podemos usar a função `mean()`:\n\n```{r}\nmean(dados$perc_desocupacao)\n```\n\nNesse caso, estamos fazendo a média de TODOS os valores da variável `prop_desocupacao`, incluindo proporções de períodos diferentes. Veremos em breve como podemos calcular a média considerando grupos (por exemplo, qual é a média em cada período?).\n\n\nA seguir, temos uma lista de funções que podem ser utilizadas para calcular estatísticas descritivas de uma variável:\n\n|  Função |  O que retorna? |\n|--:|--:|\n|  `min()` |  Valor mínimo |\n|  `max()` |  Valor máximo  |\n|  `sum()` |  Soma  |\n|  `mean()` |  Média |\n|  `weighted.mean()` |  Média ponderada |\n|  `median()` |  Mediana |\n| `quantile()` |  Quantil |\n|  `var()` |  Variância (simples) |\n|  `sd()` |  Desvio Padrão |\n\nVamos calcular algumas dessas estatísticas para a variável `perc_desocupacao`:\n\n```{r}\nmin(dados$perc_desocupacao)\nmax(dados$perc_desocupacao)\nmean(dados$perc_desocupacao)\nmedian(dados$perc_desocupacao)\nvar(dados$perc_desocupacao)\nsd(dados$perc_desocupacao)\n```\n\n\n\n\n::: callout-warning\n\nAs variáveis que estamos trabalhando não possuem valores faltantes (`NA`). Caso a variável que você esteja trabalhando possua valores faltantes, é importante considerar o argumento `na.rm = TRUE` nas funções de estatísticas descritivas, para que os valores faltantes sejam ignorados ao realizar os cálculos.\n\nPor exemplo:\n\n```{r}\naltura_personagens_starwars <- dplyr::starwars$height # <1>\nmean(altura_personagens_starwars) # <2>\n```\n1. Atribuindo a variável `height` (altura) da base `starwars` ao objeto `altura_personagens_starwars`.\n2. Tentando calcular a média da altura dos personagens de Star Wars. O resultado será `NA` pois temos `NA` na variável `altura_personagens_starwars`.\n\n```{r}\nmean(altura_personagens_starwars, na.rm = TRUE) # <1>\n```\n1. Calculando a média da altura dos personagens de Star Wars, ignorando os valores faltantes (`NA`).\n\n\n\n:::\n\n\n## Estatísticas agregadas (`summarise()`) \n\nUma função importante do pacote `dplyr` é a `summarise()`. Ela permite calcular estatísticas descritivas de variáveis de uma base de dados, usando as funções que vimos anteriormente. A diferença é que retornará um novo data frame com as estatísticas calculadas.\n\n```{r}\ntabela_resumo_perc_desocupacao <- dados |> \n  summarise(\n    minimo = min(perc_desocupacao),\n    maximo = max(perc_desocupacao),\n    amplitude = maximo - minimo,\n  )\n\ntabela_resumo_perc_desocupacao\n```\n\nPorém isso não é muito diferente de usar as funções do R diretamente, como fizemos anteriormente. \n\n\nA grande vantagem da função `summarise()` é que podemos calcular estatísticas descritivas para grupos de dados, o que veremos a seguir.\n\n## Agrupando dados (`group_by()`)\n\nImagine que queremos calcular a média da taxa de desemprego para cada estado. Para isso, precisaríamos agrupar a base de dados por cada estado.\n\nA função `group_by()` do pacote `dplyr` permite agrupar dados usando uma ou mais variáveis. Ela não faz alterações nas linhas e colunas da base de dados, porém ela cria um atributo que indica que a base de dados está agrupada. Assim, **as etapas seguintes que utilizarem a base de dados agrupada irão considerar os grupos criados**.\n\n\nVeja o exemplo a seguir: ao agrupar a base `dados` por `uf`, estamos criando grupos de dados para cada estado. Veja que o resultado é uma tibble, mas a diferença é que agora temos um grupo para cada estado (`# Groups:   uf [27]`):\n\n\n```{r}\ndados |> \n  group_by(uf)\n```\n\n\nPodemos agrupar também usando mais que uma variável. Neste exemplo, vamos agrupar por `uf` e `ano`: `uf, ano [351]`. Isso significa que temos um grupo para cada combinação de estado (27) e ano (13), totalizando 351 grupos. \n\n```{r}\ndados |> \n  group_by(uf, ano)\n```\n\n\nPodemos usar função `ungroup()` para remover os grupos criados. Porém as funções que utilizaremos muitas vezes já remove os grupos. Veremos exemplos a seguir.\n\n\n## Estatísticas agregadas utilizando grupos (`group_by()` + `summarise()`)\n\nAgora que sabemos como agrupar dados, podemos calcular estatísticas descritivas para cada grupo.\n\n### Exemplo com um grupo\n\n```{r}\ndados |> \n  group_by(uf) |>\n  summarise(\n    minimo = min(perc_desocupacao),\n    media = mean(perc_desocupacao),\n    mediana = median(perc_desocupacao),\n    maximo = max(perc_desocupacao),\n    amplitude = maximo - minimo\n  )\n```\n**Importante:** A função `summarise()` retorna um novo data frame com as colunas utilizadas para agrupar os dados e as estatísticas calculadas. \n\n### Exemplo com mais de um grupo\n\nPodemos utilizar mais que uma variável para agrupar. No exemplo a seguir, vamos agrupar por `uf` e `ano`:\n\n```{r}\ndados |> \n  group_by(uf, ano) |>\n  summarise(\n    media = mean(perc_desocupacao)\n  )\n```\nA função retornou o seguinte warning:\n\n```\n`summarise()` has grouped output by 'uf'. You can override using the `.groups` argument.\n```\nIsso significa que a função `summarise()` retornou um data frame agrupado por `uf`. Se quisermos remover o agrupamento, podemos usar o argumento `.groups = \"drop\"`:\n\n```{r}\ndados |> \n  group_by(uf, ano) |>\n  summarise(\n    media = mean(perc_desocupacao),\n    .groups = \"drop\" # <1>\n  )\n```\n1. O argumento `.groups = \"drop\"` retorna uma tibble sem grupos.\n\n\n\nOutra opção é usar a função `ungroup()`:\n\n```{r}\ndados |> \n  group_by(uf, ano) |>\n  summarise(\n    media = mean(perc_desocupacao)\n  ) |> \n  ungroup()\n```\n\n\n## Filtros com grupos (`group_by()` + `filter()`)\n\nPodemos combinar a função `group_by()` com a função `filter()` para realizar filtros que respeitem o agrupamento dos dados.\n\nPor exemplo, queremos responder a pergunta: **Qual foi período (trimestre) para cada estado onde a taxa de desocupação foi maior?**\n\nPara isso, primeiro precisamos agrupar com o estado. A primeira coisa que vem em mente é utilizar a função `summarise()` e buscar o valor máximo:\n\n```{r}\ndados |> \n  group_by(uf) |> \n  summarise(maximo = max(perc_desocupacao))\n```\n\nPorém como o `summarise()` apenas retorna as colunas de grupo e as colunas criadas, não temos a informação do trimestre. \n\n\nPara isso, podemos utilizar a função `filter()` para filtrar os dados por estado, filtrando a linha que apresenta o maior valor encontrado (`max(perc_desocupacao)`) na coluna `perc_desocupacao`:\n\n```{r}\ndados |>\n  group_by(uf) |> # <1>\n  filter(perc_desocupacao == max(perc_desocupacao)) |>  # <2>\n  arrange(desc(perc_desocupacao)) |> # <3>\n  select(uf, trimestre, perc_desocupacao) # <4>\n```\n1. Agrupando por estado (`uf`).\n2. Filtrando as linhas que apresentam o maior valor encontrado na coluna `perc_desocupacao`.\n3. Ordenando os dados de forma decrescente, segundo o `perc_desocupacao`.\n4. Selecionando apenas as colunas relevantes para a pergunta.\n\n### Criando colunas utilizando grupos (`group_by()` + `mutate()`)\n\nPodemos criar novas colunas utilizando a função `mutate()`.\n\nPodemos utilizar essa pergunta como exemplo:\n- Qual é a média da taxa de desocupação para cada trimestre? \n\nPodemos fazer calcular a média com a função `summarise()`:\n\n```{r}\ndados |>\n  group_by(trimestre) |>\n  summarise(\n    media_ponderada = weighted.mean(perc_desocupacao, mil_pessoas_total) # <1>\n  ) \n```\n1. Calculando a média ponderada da taxa de desocupação, considerando a coluna `mil_pessoas_total` como peso.\n\nA média foi calculada, porém o resultado é apenas uma tabela contendo o trimestre (a coluna de agrupamento), e a média (a coluna criada dentro do `summarise()`). Porém, se quisermos ter essa média como uma coluna da tabela, podemos fazer esse cálculo utilizando o `mutate()` \n\n```{r}\ndados_media_trimestre <- dados |>\n  group_by(trimestre) |>\n  mutate( # <1>\n    media_ponderada = weighted.mean(perc_desocupacao, mil_pessoas_total) # <2> \n  ) \n```\n1. Criando uma nova coluna com `mutate()`\n2. Calculando a média ponderada da taxa de desocupação, considerando a coluna `mil_pessoas_total` como peso.\n\n\n\n## Tabelas de frequência\n\nUtilizamos tabelas de frequência para representar a quantidade de ocorrências de linhas segundo um grupo de variáveis.\n\n\nA função `count()` do pacote `dplyr` é uma forma simples de criar tabelas de frequência.\n\nPor exemplo: Se queremos saber quantos estados temos em cada região, podemos filtrar para apenas um período (para que não haja duplicações), e contar a quantidade de linhas em cada categoria da coluna `regiao`, usando a função `count()`:\n\n```{r}\ndados_tri_recente <- dados |> \n  dplyr::filter(trimestre_codigo == \"202402\") # <1>\n```\n1. Filtrando o trimestre mais recente\n\n```{r}\ndados_tri_recente |> # <1>\n  count(regiao) # <2>\n```\n1. Usando dados filtrados para o trimestre mais recente\n2. Contando a quantidade de linhas para cada região (nesse caso, quantos estados tem por região).\n\n\nOutras funções que podem ser utilizadas para criar tabelas de frequência são: `table()` (do R base) e `tabyl()` (do pacote `janitor`).\n\nA função `table()` retorna uma tabela de frequência em formato largo. Nesse caso, o argumento é um vetor:\n\n```{r}\ntable(dados_tri_recente$regiao)\n```\n\nA função `janitor::tabyl()` gera uma tabela de frequência com o percentual de cada categoria. Nele, o argumento é um data frame, e passamos a variável que queremos contar (podemos informar mais que uma variável):\n\n```{r}\njanitor::tabyl(dados_tri_recente, regiao)\n```\n\n\n\n\n## Exercícios sugeridos\n\n\n1. Calcule a média da taxa de desocupação nos dois primeiros trimestres de 2024, por região.\n\n::: {.callout-tip collapse=\"true\"}\n## Dicas\n\nO resultado esperado é:\n\n```{r}\n#| echo: false\ndados |> \n  filter(trimestre_codigo %in% c(\"202401\", \"202402\")) |>\n  group_by(regiao) |>\n  summarise(media = mean(perc_desocupacao)) |> \n  ungroup()\n```\n:::\n\n\n2. Qual foi o período (trimestre) para cada estado onde a taxa de desocupação foi menor? Ordene o resultado de forma crescente.\n\n::: {.callout-tip collapse=\"true\"}\n## Dicas\n\nLembre-se de que podemos fazer filtros agrupados!\n\nO resultado esperado é:\n\n```{r}\n#| echo: false\ndados |> \n  group_by(uf) |> \n  filter(perc_desocupacao == min(perc_desocupacao)) |> \n  arrange(perc_desocupacao) |> \n  select(uf, trimestre, perc_desocupacao)  |> \n  ungroup()\n```\n:::\n\n3. Qual foi a mediana da taxa de desocupação para cada estado, durante o período da pandemia? Ordene o resultado de forma decrescente.\n\n\n::: {.callout-tip collapse=\"true\"}\n## Dicas\n\nO resultado esperado é:\n\n```{r}\n#| echo: false\ndados |> \n  filter(periodo_pandemia == 1) |> \n  group_by(uf) |> \n  summarise(mediana = median(perc_desocupacao)) |> \n  arrange(desc(mediana)) |> \n  ungroup()\n```\n:::\n\n## Sugestões de materiais\n\n- Livro [Metodologia de Pesquisa Jurimétrica](https://livro.abj.org.br/):\n  - [Capítulo 3 - Estatísticas](https://livro.abj.org.br/03-estatisticas.html)\n  ","srcMarkdownNoYaml":"\n\nNesta aula:\n\n- Conheceremos funções para calcular estatísticas descritivas, como média, mediana, variância, desvio padrão, entre outras. \n\n- Discutiremos como agrupar dados e calcular estatísticas descritivas para cada grupo.\n\n- Aprenderemos a elaborar tabelas de frequência.\n\nUma etapa importante da análise exploratória de dados envolve visualizar dados. Isso será apresentado na próxima aula!\n\n## Importando dados\n\nNesta aula, utilizaremos a tabela preparada na [aula anterior](05_transformacao): `\"dados_output/sidra_4092_arrumado.rds\"`.\n\n::: {.callout-important collapse=\"true\"}\n### Expanda para fazer download da base de dados\n\nCaso não tenha o arquivo da tabela que utilizaremos, você pode baixar [aqui](https://github.com/ipeadata-lab/curso_r_intro_202409/raw/refs/heads/main/dados_output/sidra_4092_arrumado.rds), e copiar o arquivo para a pasta `dados_output` do seu projeto.\n\nOutra opção é executar o código abaixo:\n\n```{r}\n#| eval: false\ndownload.file(\n  url = \"https://github.com/ipeadata-lab/curso_r_intro_202409/raw/refs/heads/main/dados_output/sidra_4092_arrumado.rds\",  # <1>\n  destfile = \"dados_output/sidra_4092_arrumado.rds\", # <2>\n  mode = \"wb\" # <3>\n  )\n```\n\n1.  URL que desejamos baixar\n2.  Caminho onde queremos baixar o arquivo (diretório + nome do arquivo + extensão do arquivo)\n3.  Configuração que evita corromper arquivos binários.\n:::\n\nVamos carregar a base de dados com a função `read_rds()`:\n\n```{r}\n#| message: false\nlibrary(dplyr) # <1>\ndados <- readr::read_rds(\"dados_output/sidra_4092_arrumado.rds\") # <2>\nglimpse(dados) # <3>\n```\n1. Carregando o pacote dplyr\n2. Importando os dados\n3. Espiando a tabela\n\n\n\n\n## Estatísticas descritivas\n\n\nNa aula [conhecendo os dados](04_conhecendo.qmd), vimos algumas funções que são interessantes para ver estatísticas descritivas de todas as variáveis de uma vez, como a `summary()` e a `skim()`.\n\nPodemos utilizar também funções do R para calcular estatísticas descritivas de uma variável.\n\nPor exemplo, para calcular a média da variável `perc_desocupacao`, podemos usar a função `mean()`:\n\n```{r}\nmean(dados$perc_desocupacao)\n```\n\nNesse caso, estamos fazendo a média de TODOS os valores da variável `prop_desocupacao`, incluindo proporções de períodos diferentes. Veremos em breve como podemos calcular a média considerando grupos (por exemplo, qual é a média em cada período?).\n\n\nA seguir, temos uma lista de funções que podem ser utilizadas para calcular estatísticas descritivas de uma variável:\n\n|  Função |  O que retorna? |\n|--:|--:|\n|  `min()` |  Valor mínimo |\n|  `max()` |  Valor máximo  |\n|  `sum()` |  Soma  |\n|  `mean()` |  Média |\n|  `weighted.mean()` |  Média ponderada |\n|  `median()` |  Mediana |\n| `quantile()` |  Quantil |\n|  `var()` |  Variância (simples) |\n|  `sd()` |  Desvio Padrão |\n\nVamos calcular algumas dessas estatísticas para a variável `perc_desocupacao`:\n\n```{r}\nmin(dados$perc_desocupacao)\nmax(dados$perc_desocupacao)\nmean(dados$perc_desocupacao)\nmedian(dados$perc_desocupacao)\nvar(dados$perc_desocupacao)\nsd(dados$perc_desocupacao)\n```\n\n\n\n\n::: callout-warning\n\nAs variáveis que estamos trabalhando não possuem valores faltantes (`NA`). Caso a variável que você esteja trabalhando possua valores faltantes, é importante considerar o argumento `na.rm = TRUE` nas funções de estatísticas descritivas, para que os valores faltantes sejam ignorados ao realizar os cálculos.\n\nPor exemplo:\n\n```{r}\naltura_personagens_starwars <- dplyr::starwars$height # <1>\nmean(altura_personagens_starwars) # <2>\n```\n1. Atribuindo a variável `height` (altura) da base `starwars` ao objeto `altura_personagens_starwars`.\n2. Tentando calcular a média da altura dos personagens de Star Wars. O resultado será `NA` pois temos `NA` na variável `altura_personagens_starwars`.\n\n```{r}\nmean(altura_personagens_starwars, na.rm = TRUE) # <1>\n```\n1. Calculando a média da altura dos personagens de Star Wars, ignorando os valores faltantes (`NA`).\n\n\n\n:::\n\n\n## Estatísticas agregadas (`summarise()`) \n\nUma função importante do pacote `dplyr` é a `summarise()`. Ela permite calcular estatísticas descritivas de variáveis de uma base de dados, usando as funções que vimos anteriormente. A diferença é que retornará um novo data frame com as estatísticas calculadas.\n\n```{r}\ntabela_resumo_perc_desocupacao <- dados |> \n  summarise(\n    minimo = min(perc_desocupacao),\n    maximo = max(perc_desocupacao),\n    amplitude = maximo - minimo,\n  )\n\ntabela_resumo_perc_desocupacao\n```\n\nPorém isso não é muito diferente de usar as funções do R diretamente, como fizemos anteriormente. \n\n\nA grande vantagem da função `summarise()` é que podemos calcular estatísticas descritivas para grupos de dados, o que veremos a seguir.\n\n## Agrupando dados (`group_by()`)\n\nImagine que queremos calcular a média da taxa de desemprego para cada estado. Para isso, precisaríamos agrupar a base de dados por cada estado.\n\nA função `group_by()` do pacote `dplyr` permite agrupar dados usando uma ou mais variáveis. Ela não faz alterações nas linhas e colunas da base de dados, porém ela cria um atributo que indica que a base de dados está agrupada. Assim, **as etapas seguintes que utilizarem a base de dados agrupada irão considerar os grupos criados**.\n\n\nVeja o exemplo a seguir: ao agrupar a base `dados` por `uf`, estamos criando grupos de dados para cada estado. Veja que o resultado é uma tibble, mas a diferença é que agora temos um grupo para cada estado (`# Groups:   uf [27]`):\n\n\n```{r}\ndados |> \n  group_by(uf)\n```\n\n\nPodemos agrupar também usando mais que uma variável. Neste exemplo, vamos agrupar por `uf` e `ano`: `uf, ano [351]`. Isso significa que temos um grupo para cada combinação de estado (27) e ano (13), totalizando 351 grupos. \n\n```{r}\ndados |> \n  group_by(uf, ano)\n```\n\n\nPodemos usar função `ungroup()` para remover os grupos criados. Porém as funções que utilizaremos muitas vezes já remove os grupos. Veremos exemplos a seguir.\n\n\n## Estatísticas agregadas utilizando grupos (`group_by()` + `summarise()`)\n\nAgora que sabemos como agrupar dados, podemos calcular estatísticas descritivas para cada grupo.\n\n### Exemplo com um grupo\n\n```{r}\ndados |> \n  group_by(uf) |>\n  summarise(\n    minimo = min(perc_desocupacao),\n    media = mean(perc_desocupacao),\n    mediana = median(perc_desocupacao),\n    maximo = max(perc_desocupacao),\n    amplitude = maximo - minimo\n  )\n```\n**Importante:** A função `summarise()` retorna um novo data frame com as colunas utilizadas para agrupar os dados e as estatísticas calculadas. \n\n### Exemplo com mais de um grupo\n\nPodemos utilizar mais que uma variável para agrupar. No exemplo a seguir, vamos agrupar por `uf` e `ano`:\n\n```{r}\ndados |> \n  group_by(uf, ano) |>\n  summarise(\n    media = mean(perc_desocupacao)\n  )\n```\nA função retornou o seguinte warning:\n\n```\n`summarise()` has grouped output by 'uf'. You can override using the `.groups` argument.\n```\nIsso significa que a função `summarise()` retornou um data frame agrupado por `uf`. Se quisermos remover o agrupamento, podemos usar o argumento `.groups = \"drop\"`:\n\n```{r}\ndados |> \n  group_by(uf, ano) |>\n  summarise(\n    media = mean(perc_desocupacao),\n    .groups = \"drop\" # <1>\n  )\n```\n1. O argumento `.groups = \"drop\"` retorna uma tibble sem grupos.\n\n\n\nOutra opção é usar a função `ungroup()`:\n\n```{r}\ndados |> \n  group_by(uf, ano) |>\n  summarise(\n    media = mean(perc_desocupacao)\n  ) |> \n  ungroup()\n```\n\n\n## Filtros com grupos (`group_by()` + `filter()`)\n\nPodemos combinar a função `group_by()` com a função `filter()` para realizar filtros que respeitem o agrupamento dos dados.\n\nPor exemplo, queremos responder a pergunta: **Qual foi período (trimestre) para cada estado onde a taxa de desocupação foi maior?**\n\nPara isso, primeiro precisamos agrupar com o estado. A primeira coisa que vem em mente é utilizar a função `summarise()` e buscar o valor máximo:\n\n```{r}\ndados |> \n  group_by(uf) |> \n  summarise(maximo = max(perc_desocupacao))\n```\n\nPorém como o `summarise()` apenas retorna as colunas de grupo e as colunas criadas, não temos a informação do trimestre. \n\n\nPara isso, podemos utilizar a função `filter()` para filtrar os dados por estado, filtrando a linha que apresenta o maior valor encontrado (`max(perc_desocupacao)`) na coluna `perc_desocupacao`:\n\n```{r}\ndados |>\n  group_by(uf) |> # <1>\n  filter(perc_desocupacao == max(perc_desocupacao)) |>  # <2>\n  arrange(desc(perc_desocupacao)) |> # <3>\n  select(uf, trimestre, perc_desocupacao) # <4>\n```\n1. Agrupando por estado (`uf`).\n2. Filtrando as linhas que apresentam o maior valor encontrado na coluna `perc_desocupacao`.\n3. Ordenando os dados de forma decrescente, segundo o `perc_desocupacao`.\n4. Selecionando apenas as colunas relevantes para a pergunta.\n\n### Criando colunas utilizando grupos (`group_by()` + `mutate()`)\n\nPodemos criar novas colunas utilizando a função `mutate()`.\n\nPodemos utilizar essa pergunta como exemplo:\n- Qual é a média da taxa de desocupação para cada trimestre? \n\nPodemos fazer calcular a média com a função `summarise()`:\n\n```{r}\ndados |>\n  group_by(trimestre) |>\n  summarise(\n    media_ponderada = weighted.mean(perc_desocupacao, mil_pessoas_total) # <1>\n  ) \n```\n1. Calculando a média ponderada da taxa de desocupação, considerando a coluna `mil_pessoas_total` como peso.\n\nA média foi calculada, porém o resultado é apenas uma tabela contendo o trimestre (a coluna de agrupamento), e a média (a coluna criada dentro do `summarise()`). Porém, se quisermos ter essa média como uma coluna da tabela, podemos fazer esse cálculo utilizando o `mutate()` \n\n```{r}\ndados_media_trimestre <- dados |>\n  group_by(trimestre) |>\n  mutate( # <1>\n    media_ponderada = weighted.mean(perc_desocupacao, mil_pessoas_total) # <2> \n  ) \n```\n1. Criando uma nova coluna com `mutate()`\n2. Calculando a média ponderada da taxa de desocupação, considerando a coluna `mil_pessoas_total` como peso.\n\n\n\n## Tabelas de frequência\n\nUtilizamos tabelas de frequência para representar a quantidade de ocorrências de linhas segundo um grupo de variáveis.\n\n\nA função `count()` do pacote `dplyr` é uma forma simples de criar tabelas de frequência.\n\nPor exemplo: Se queremos saber quantos estados temos em cada região, podemos filtrar para apenas um período (para que não haja duplicações), e contar a quantidade de linhas em cada categoria da coluna `regiao`, usando a função `count()`:\n\n```{r}\ndados_tri_recente <- dados |> \n  dplyr::filter(trimestre_codigo == \"202402\") # <1>\n```\n1. Filtrando o trimestre mais recente\n\n```{r}\ndados_tri_recente |> # <1>\n  count(regiao) # <2>\n```\n1. Usando dados filtrados para o trimestre mais recente\n2. Contando a quantidade de linhas para cada região (nesse caso, quantos estados tem por região).\n\n\nOutras funções que podem ser utilizadas para criar tabelas de frequência são: `table()` (do R base) e `tabyl()` (do pacote `janitor`).\n\nA função `table()` retorna uma tabela de frequência em formato largo. Nesse caso, o argumento é um vetor:\n\n```{r}\ntable(dados_tri_recente$regiao)\n```\n\nA função `janitor::tabyl()` gera uma tabela de frequência com o percentual de cada categoria. Nele, o argumento é um data frame, e passamos a variável que queremos contar (podemos informar mais que uma variável):\n\n```{r}\njanitor::tabyl(dados_tri_recente, regiao)\n```\n\n\n\n\n## Exercícios sugeridos\n\n\n1. Calcule a média da taxa de desocupação nos dois primeiros trimestres de 2024, por região.\n\n::: {.callout-tip collapse=\"true\"}\n## Dicas\n\nO resultado esperado é:\n\n```{r}\n#| echo: false\ndados |> \n  filter(trimestre_codigo %in% c(\"202401\", \"202402\")) |>\n  group_by(regiao) |>\n  summarise(media = mean(perc_desocupacao)) |> \n  ungroup()\n```\n:::\n\n\n2. Qual foi o período (trimestre) para cada estado onde a taxa de desocupação foi menor? Ordene o resultado de forma crescente.\n\n::: {.callout-tip collapse=\"true\"}\n## Dicas\n\nLembre-se de que podemos fazer filtros agrupados!\n\nO resultado esperado é:\n\n```{r}\n#| echo: false\ndados |> \n  group_by(uf) |> \n  filter(perc_desocupacao == min(perc_desocupacao)) |> \n  arrange(perc_desocupacao) |> \n  select(uf, trimestre, perc_desocupacao)  |> \n  ungroup()\n```\n:::\n\n3. Qual foi a mediana da taxa de desocupação para cada estado, durante o período da pandemia? Ordene o resultado de forma decrescente.\n\n\n::: {.callout-tip collapse=\"true\"}\n## Dicas\n\nO resultado esperado é:\n\n```{r}\n#| echo: false\ndados |> \n  filter(periodo_pandemia == 1) |> \n  group_by(uf) |> \n  summarise(mediana = median(perc_desocupacao)) |> \n  arrange(desc(mediana)) |> \n  ungroup()\n```\n:::\n\n## Sugestões de materiais\n\n- Livro [Metodologia de Pesquisa Jurimétrica](https://livro.abj.org.br/):\n  - [Capítulo 3 - Estatísticas](https://livro.abj.org.br/03-estatisticas.html)\n  "},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":true,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"toc-depth":5,"output-file":"06_analise_exploratoria.html"},"language":{"toc-title-document":"Índice","toc-title-website":"Nesta página","related-formats-title":"Outros formatos","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Fonte","other-links-title":"Outros Links","code-links-title":"Ligações de código","launch-dev-container-title":"Iniciar Dev Container","launch-binder-title":"Iniciar Binder","article-notebook-label":"Caderno do Artigo","notebook-preview-download":"Baixar Caderno","notebook-preview-download-src":"Descarregar código fonte","notebook-preview-back":"Voltar ao Artigo","manuscript-meca-bundle":"Arquivo MECA","section-title-abstract":"Resumo","section-title-appendices":"Apêndices","section-title-footnotes":"Notas de rodapé","section-title-references":"Referências","section-title-reuse":"Reuso","section-title-copyright":"Direito autoral","section-title-citation":"Citação","appendix-attribution-cite-as":"Por favor, cite este trabalho como:","appendix-attribution-bibtex":"BibTeX","appendix-view-license":"Ver Licença","title-block-author-single":"Autor","title-block-author-plural":"Autores","title-block-affiliation-single":"Afiliação","title-block-affiliation-plural":"Afiliações","title-block-published":"Data de Publicação","title-block-modified":"Data de Modificação","title-block-keywords":"Palavras-chave","callout-tip-title":"Dica","callout-note-title":"Nota","callout-warning-title":"Aviso","callout-important-title":"Importante","callout-caution-title":"Cuidado","code-summary":"Código","code-tools-menu-caption":"Código","code-tools-show-all-code":"Mostrar o código","code-tools-hide-all-code":"Esconder o código","code-tools-view-source":"Ver o código fonte","code-tools-source-code":"Código fonte","tools-share":"Share","tools-download":"Download","code-line":"Linha","code-lines":"Linhas","copy-button-tooltip":"Copiar para a área de transferência","copy-button-tooltip-success":"Copiada","repo-action-links-edit":"Editar essa página","repo-action-links-source":"Ver o código fonte","repo-action-links-issue":"Criar uma issue","back-to-top":"De volta ao topo","search-no-results-text":"Nenhum resultado","search-matching-documents-text":"documentos correspondentes","search-copy-link-title":"Copiar link para a busca","search-hide-matches-text":"Esconder correspondências adicionais","search-more-match-text":"mais correspondência neste documento","search-more-matches-text":"mais correspondências neste documento","search-clear-button-title":"Limpar","search-text-placeholder":"","search-detached-cancel-button-title":"Cancelar","search-submit-button-title":"Enviar","search-label":"Procurar","toggle-section":"Alternar seção","toggle-sidebar":"Alternar barra lateral","toggle-dark-mode":"Alternar modo escuro","toggle-reader-mode":"Alternar modo de leitor","toggle-navigation":"Alternar de navegação","crossref-fig-title":"Figura","crossref-tbl-title":"Tabela","crossref-lst-title":"Listagem","crossref-thm-title":"Teorema","crossref-lem-title":"Lema","crossref-cor-title":"Corolário","crossref-prp-title":"Proposição","crossref-cnj-title":"Conjetura","crossref-def-title":"Definição","crossref-exm-title":"Exemplo","crossref-exr-title":"Exercício","crossref-ch-prefix":"Capítulo","crossref-apx-prefix":"Apêndice","crossref-sec-prefix":"Seção","crossref-eq-prefix":"Equação","crossref-lof-title":"Lista de Figuras","crossref-lot-title":"Lista de Tabelas","crossref-lol-title":"Lista de Listagens","environment-proof-title":"Comprovação","environment-remark-title":"Comentário","environment-solution-title":"Solução","listing-page-order-by":"Ordenar por","listing-page-order-by-default":"Pré-selecionado","listing-page-order-by-date-asc":"Mais velho","listing-page-order-by-date-desc":"O mais novo","listing-page-order-by-number-desc":"Decrescente","listing-page-order-by-number-asc":"Crescente","listing-page-field-date":"Data","listing-page-field-title":"Título","listing-page-field-description":"Descrição","listing-page-field-author":"Autor","listing-page-field-filename":"Nome do arquivo","listing-page-field-filemodified":"Arquivo modificado","listing-page-field-subtitle":"Subtítulo","listing-page-field-readingtime":"Tempo de leitura","listing-page-field-wordcount":"Contagem de Palavras","listing-page-field-categories":"Categorias","listing-page-minutes-compact":"{0} minutos","listing-page-category-all":"Tudo","listing-page-no-matches":"Nenhum item correspondente","listing-page-words":"{0} palavras","listing-page-filter":"Filtro","draft":"Rascunho"},"metadata":{"lang":"pt","fig-responsive":true,"quarto-version":"1.5.57","page-navigation":true,"page-footer":{"border":true,"left":"Copyright 2024, Beatriz Milz e IPEA/COCD","right":[{"icon":"github","href":"https://github.com/ipeadata-lab/curso_r_intro_202409s"}]},"bibliography":["references.bib"],"editor":"source","theme":"cosmo","title":"Análise exploratória de dados","code-annotations":"hover"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}