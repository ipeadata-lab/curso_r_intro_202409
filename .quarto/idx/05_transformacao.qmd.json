{"title":"Transformando dados","markdown":{"yaml":{"title":"Transformando dados","code-annotations":"hover"},"headingText":"Introdução","containsRefs":false,"markdown":"\n\n\nPrimeiramente, precisamos carregar o pacote `tidyverse` e a base de dados que vamos utilizar. A base de dados é a tabela 4092 do SIDRA, que apresenta dados sobre \"pessoas de 14 anos ou mais de idade por condição em relação à força de trabalho e condição de ocupação\"[^transformacao-dados], e foi baixada previamente (em [Importando dados](03_importacao.html#pacote-sidrar)).\n\n[^transformacao-dados]: É interessante conhecer mais sobre a base de dados que estamos utilizando. O IBGE apresenta alguns conteúdos interessantes, como a página com informações sobre a [PNAD Contínua Trimestral](https://www.ibge.gov.br/estatisticas/sociais/trabalho/9173-pesquisa-nacional-por-amostra-de-domicilios-continua-trimestral.html?edicao=41004), e também a [página sobre desemprego](https://www.ibge.gov.br/explica/desemprego.php) que nos ajuda a entender as variáveis presentes.\n\n\nNeste capítulo, vamos explorar as funções de transformação de dados do pacote `dplyr`, a partir da pergunta norteadora abaixo:\n\n> Considerando que a tabela 4092 apresenta dados sobre \"pessoas de 14 anos ou mais de idade por condição em relação à força de trabalho e condição de ocupação\", **qual é a taxa de desocupação de cada estado e região do Brasil ao longo do tempo?**\n\n\n```{r}\n#| message: false\nlibrary(dplyr)\ndados_brutos <- readr::read_rds(\"dados/sidrar_4092_bruto.rds\") \n```\n\n\n## Linhas, colunas e objetivo de análise\n\nUma pergunta que é sempre importante ter em mente ao analisar dados é: O que cada linha representa? Na estatística, esse é o conceito da **unidade observacional**.\n\nO objeto `dados_brutos` apresenta uma linha para cada combinação das seguintes variáveis:\n\n  - `Trimestre (Código)` / `Trimestre`\n\n  - `Unidade da Federação` / `Unidade da Federação (Código)`\n\n  - `Variável` / `Variável (Código)`\n  \n  - `Condição em relação à força de trabalho e condição de ocupação` e `Condição em relação à força de trabalho e condição de ocupação (Código)`\n\nPodemos consultar os valores distintos possíveis no R, para garantir que estamos selecionando corretamente os valores de interesse.\n\nAs variáveis disponíveis na base de dados, e suas unidades de medida são:\n\n```{r}\ndados_brutos |>\n  distinct(`Variável`, `Unidade de Medida`) # <1>\n```\n1. Colunas que queremos buscar os valores distintos\n\nPodemos observar, cada linha representa uma combinação de trimestre, unidade da federação e variável. \n\nOutras perguntas relevantes ao analisar dados são:\n\n  - Qual é a pergunta que eu quero responder com esses dados?\n  - Quais são as variáveis que eu preciso para responder essa pergunta?\n\n\n## Padronizar nome das colunas\n\nÉ uma boa prática padronizar o nome das colunas de um data frame. Assim evitamos problemas de codificação de caracteres (*encoding*), facilitamos a legibilidade do código e evitamos possíveis erros ao acessar as colunas.\n\nO pacote `janitor` possui a função `clean_names()`, que padroniza os nomes das colunas de um *data frame*. Ele substitui espaços por *underline* (`_`), remove caracteres especiais, e transforma o texto em minúsculo, garantindo maior consistência ao lidar com os dados. Isso evita erros ao acessar colunas.\n\n```{r}\nnames(dados_brutos) # <1>\n```\n1. Checar o nome das colunas da base de dados\n\n\n```{r}\ndados_renomeados <- janitor::clean_names(dados_brutos)  # <1>\n\nnames(dados_renomeados)  # <2>\n```\n1. Limpar nomes das colunas da base de dados, e salvar em um novo objeto chamado `dados_renomeados`\n2. Checar o nome das colunas da base de dados renomeada\n\n\n## Pipe - Encadeando funções\n\nNos exemplos anteriores, utilizamos uma função por vez, para facilitar a compreensão de cada etapa. No entanto, à medida que nos familiarizamos com as funções, podemos encadear várias delas em um único fluxo de código usando o operador *pipe* (`%>%` ou `|>`). Isso torna o código mais conciso e elimina a criação de objetos intermediários desnecessários.\n\nPorém, é importante ter cuidado para não criar sequências muito longas e difíceis de entender.\n\n\n## Filtrando linhas (`filter()`)\n\nPara responder à pergunta norteadora, não precisamos de todas as variáveis presentes na base de dados. Podemos **filtrar** as linhas que são relevantes para a análise, escolhendo as variáveis de interesse.\n\nNesse caso, podemos filtrar os dados onde a variável é igual à `\"Pessoas de 14 anos ou mais de idade\"`.\n\n```{r}\ndados_filtrados <- dados_renomeados |>\n  filter(variavel == \"Pessoas de 14 anos ou mais de idade\")\n```\n\n\nPara verificar se o filtro foi feito corretamente, podemos checar o número de linhas de cada base de dados:\n\n```{r}\nnrow(dados_renomeados)\nnrow(dados_filtrados)\n```\n\nPodemos verificar também os valores distintos para as colunas `variavel` e `unidade_de_medida` na base de dados `dados_filtrados`:\n\n```{r}\ndados_filtrados |>\n  distinct(variavel, unidade_de_medida)\n```\n\nAgora sabemos que a base de dados `dados_filtrados` contém apenas dados sobre a variável `\"Pessoas de 14 anos ou mais de idade\"`, e que a unidade de medida da coluna `valor` é mil pessoas.\n\n::: callout-tip\n## Várias formas de filtrar as linhas\nComo citamos anteriormente, em algumas situações existem várias formas diferentes de realizar uma tarefa.\n\nNo caso da função `filter()`, podemos utilizar diferentes operadores lógicos ou funções auxiliares para fazer filtros.\n\nOs exemplos abaixo podem ser úteis para consulta futura!\n\nPara esses exemplos, vamos utilizar a tabela `starwars` do pacote `dplyr`. Nessa tabela, cada linha representa um personagem de Star Wars, e as colunas representam diferentes características desses personagens.\n\n#### Exemplos de operadores lógicos:\n\n| Operador | Descrição | Exemplo | Interpretação |\n|----|-------|--------|-----------|\n| `==`     | Igual à  | `species == \"Human\"` | Todas as linhas cuja espécie é \"Human\" |\n| `!=`     | Diferente de | `species != \"Human\"` | Todas as linhas cuja espécie **não é** \"Human\"|\n| `>`      | Maior que | `height > 180` | Todas as linhas cuja altura é maior que 180 |\n| `>=`     | Maior ou igual a | `height >= 180` | Todas as linhas cuja altura é maior ou igual a 180 |\n| `<`      | Menor que | `height < 180` | Todas as linhas cuja altura é menor que 180 |\n| `<=`     | Menor ou igual a | `height <= 180` | Todas as linhas cuja altura é menor ou igual a 180 |\n| `%in%`   | Está em um conjunto | `species %in% c(\"Human\", \"Droid\")` | Todas as linhas cuja espécie é \"Human\" ou \"Droid\" |\n| `!`      | Negação | `!is.na(height)` | Todas as linhas cuja altura **não é** `NA` |\n|`!` e `%in%` | Negação de um conjunto | `!(species %in% c(\"Human\", \"Droid\"))` | Todas as linhas cuja espécie **não é** \"Human\" ou \"Droid\" |\n\n#### Exemplos de funções auxiliares:\n\n| Função | Descrição | Exemplo | Interpretação |\n|----|-------|--------|-----------|\n| `str_detect()` | Detecta padrões em textos | `str_detect(name, \"Skywalker\")` | Todas as linhas cujo nome contém \"Skywalker\" |\n| `str_starts()` | Detecta padrões no início de textos | `str_starts(name, \"Luke\")` | Todas as linhas cujo nome começa com \"Luke\" |\n| `str_ends()` | Detecta padrões no final de textos | `str_ends(name, \"Vader\")` | Todas as linhas cujo nome termina com \"Vader\" |\n:::\n\n\n## Selecionando colunas (`select()`)\n\nAlgumas colunas não são relevantes para responder à pergunta norteadora. Podemos **selecionar** apenas as colunas que vamos utilizar através da função `select()`:\n\n```{r}\ndados_selecionados <-\n  dados_filtrados |>\n  select(\n    # colunas que queremos manter\n    unidade_da_federacao,\n    unidade_da_federacao_codigo,\n    trimestre,\n    trimestre_codigo,\n    condicao_em_relacao_a_forca_de_trabalho_e_condicao_de_ocupacao,\n    valor\n  )\n\nglimpse(dados_selecionados)\n```\n\n\n::: callout-tip\n## Várias formas de selecionar colunas\n\nOs exemplos abaixo podem ser úteis para consulta futura!\n\nPara esses exemplos, vamos utilizar a tabela `starwars` do pacote `dplyr`:\n\n#### Exemplos de seleção de colunas:\n| Operador | Descrição | Exemplo | Interpretação |\n|----|-------|--------|-----------|\n| `:` | Seleciona um intervalo de colunas | `name:mass` | Todas as colunas entre `name` e `mass` |\n| `c()` | Seleciona colunas específicas | `c(name, height, mass)` | Apenas as colunas `name`, `height` e `mass` |\n| `-c()` | Exclui colunas específicas | `-c(name, height, mass)` | Todas as colunas, exceto `name`, `height` e `mass` |\n\n#### Exemplos de funções auxiliares:\n| Função | Descrição | Exemplo | Interpretação |\n|----|-------|--------|-----------|\n| `starts_with()` | Seleciona colunas que começam com um prefixo | `starts_with(\"h\")` | Todas as colunas que começam com \"h\" |\n| `ends_with()` | Seleciona colunas que terminam com um sufixo | `ends_with(\"color\")` | Todas as colunas que terminam com \"color\" |\n| `contains()` | Seleciona colunas que contêm um padrão | `contains(\"e\")` | Todas as colunas que contêm \"e\" |\n:::\n\n\n\n## Renomeando colunas (`rename()`)\n\nPodemos renomear colunas com a função `rename()`. Vamos renomear algumas colunas para facilitar o uso posteriormente:\n\n```{r}\ndados_renomeados_2 <- dados_selecionados |>\n  rename(\n    # colunas que queremos renomear: novo_nome = nome_atual\n    condicao = condicao_em_relacao_a_forca_de_trabalho_e_condicao_de_ocupacao,\n    valor_mil_pessoas = valor,\n    uf = unidade_da_federacao,\n    uf_codigo = unidade_da_federacao_codigo\n  )\n\nglimpse(dados_renomeados_2)\n```\n\n\n\n\n\n## Transformando a estrutura da tabela (`pivot_wider()` e `pivot_longer()`)\n\nAinda considerando nossa pergunta norteadora, queremos calcular a taxa de desocupação de cada estado e região do Brasil ao longo do tempo. Para isso, é mais fácil trabalhar com a tabela onde cada linha represente uma UF por trimestre, e as categorias da variável `condicao` sejam transformadas em colunas. \n\nPara fazer essa transformação, podemos usar a função `pivot_wider()`, do pacote `{tidyr}`.\n\nA função `pivot_wider()` é útil quando queremos reorganizar uma tabela, transformando variáveis categóricas em novas colunas. Essa estrutura facilita cálculos comparativos e análises entre as diferentes categorias.\n\nPor exemplo, no formato atual (dados longos), temos uma linha para cada combinação de UF, trimestre e condição de ocupação. Ao usarmos `pivot_wider()`, vamos transformar a tabela para que cada linha represente uma UF por trimestre, e as diferentes condições de ocupação (empregado, desocupado, etc.) se tornem colunas.\n\n```{r}\ndados_largos <- dados_renomeados_2 |> \n  tidyr::pivot_wider(\n  names_from = condicao, # <1>\n  values_from = valor_mil_pessoas, # <2>\n  names_prefix = \"mil_pessoas_\" # <3>\n)\n```\n1. `names_from = `: Nome da coluna de onde os **nomes** das novas colunas serão extraídos\n2. `values_from = `: Nome da coluna de onde os **valores** para preencher as novas colunas serão extraídos \n3. `names_prefix = `: Podemos adicionar um texto como prefixo. Nesse caso, isso é opcional, mas é útil para ficar claro qual é a unidade de medida das variáveis.\n\n\n```{r}\nglimpse(dados_largos)\n```\n\nAgora temos uma tabela onde cada linha representa uma UF por trimestre, e as categorias da variável `condicao` se tornaram colunas. Porém agora temos colunas com nomes que estão com caracteres especiais, e podemos arrumar isso com a função `clean_names()`.\n\n```{r}\ndados_largos_renomeados <- janitor::clean_names(dados_largos)\nglimpse(dados_largos_renomeados)\n```\n\n::: callout-info\nAs funções `pivot_longer()` e `pivot_wider()` são usadas para alternar entre dados 'longos' e 'largos'. Normalmente, dados longos são mais fáceis de visualizar, enquanto dados largos são melhores para realizar cálculos comparativos entre categorias. Para cada análise, sempre existe um formato mais apropriado a considerar.\n:::\n\n\n## Criando e transformando colunas (`mutate()`)\n\nPara criar novas colunas, ou transformar colunas que já existem, podemos usar a função `mutate()`.\n\n### Alterando os tipos de variáveis\n\nA variável `uf_codigo` está armazenada como valor numérico. No entanto, como não realizaremos operações matemáticas com esses valores, é mais apropriado transformá-los em fatores, o que facilita a análise e previne erros em cálculos futuros.\n\nExistem várias funções para transformar variáveis de um tipo para outro, como `as.factor()`, `as.character()`, `as.numeric()`, `as.Date()`,  etc.\n\n```{r}\ndados_tipo <- dados_largos_renomeados |>\n  mutate(\n    # nova variável:\n    # nome_da_coluna = o que queremos calcular\n    uf_codigo = as.factor(uf_codigo)\n    )\n```\n\n### Calculando a taxa de desocupação\n\nPara calcular a taxa de desocupação, precisamos criar uma nova variável representando a proporção de pessoas desocupadas em relação ao total de pessoas economicamente ativas.\n\n```{r}\ndados_com_proporcao <- dados_tipo |>\n  mutate(\n    prop_desocupacao = mil_pessoas_forca_de_trabalho_desocupada / mil_pessoas_forca_de_trabalho, # <1>\n    perc_desocupacao = prop_desocupacao * 100 # <2>\n  )\n```\n1. Calculando a proporção da desocupação: para cada linha, vamos dividir o valor `mil_pessoas_forca_de_trabalho_desocupada` por `mil_pessoas_forca_de_trabalho`. \n2. Multiplicando por 100 para transformar em percentual.\n\n\n### Criando uma variável **trimestre_inicio**\n\nPodemos criar uma nova variável chamada `trimestre_inicio` para  representar a data de início de cada trimestre. Para isso, precisaremos criar algumas outras variáveis \"auxiliares\" a partir da variável `trimestre_codigo`: `ano`, `trimestre_numero` e `trimestre_mes_inicio`.\n\n```{r}\ndados_com_trimestre <- dados_com_proporcao |>\n  mutate(\n    ano = stringr::str_sub(trimestre_codigo, 1, 4), # <1>\n    ano = as.numeric(ano), # <2>\n    \n    trimestre_numero = stringr::str_sub(trimestre_codigo, 5, 6),  # <3>\n    trimestre_numero = as.numeric(trimestre_numero), # <4>\n    \n    trimestre_mes_inicio = case_when( # <5>\n      trimestre_numero == 1 ~ 1,\n      trimestre_numero == 2 ~ 4,\n      trimestre_numero == 3 ~ 7,\n      trimestre_numero == 4 ~ 10\n    ),\n    \n    trimestre_inicio = paste0(ano, \"-\", trimestre_mes_inicio, \"-01\"),  # <6>\n    trimestre_inicio = as.Date(trimestre_inicio),  # <7>\n    \n    .after = trimestre_codigo # <8>\n  ) |> \n  select(-trimestre_mes_inicio, -trimestre_numero) # <9>\n```\n1. Extrair os 4 primeiros caracteres do código do trimestre\n2. Convertendo a coluna `ano` de texto para numérico\n3. Extrair os 2 últimos caracteres do código do trimestre\n4. Convertendo a coluna `trimestre_numero` de texto para numérico\n5. Criar variável com o mês de início do trimestre\n6. Criar variável com data de início do trimestre (neste momento, com tipo texto), colando os valores do mês e ano.\n7. Convertendo a coluna `trimestre_inicio` de texto para Data\n8. Queremos adicionar as colunas novas após a coluna `trimestre_codigo`\n9. Removendo colunas que não serão necessárias\n\n\n### Criando uma variável *dummy*\n\nUma variável *dummy* é uma variável binária que indica a presença ou ausência de algum atributo.\n\nPodemos criar uma variável dummy para identificar os trimestres que ocorreram durante o período de emergência em saúde pública de importância nacional de COVID-19. Para isso, vamos criar uma nova variável chamada `periodo_pandemia`, que será `1` para os trimestres que ocorreram durante a pandemia, e `0` para os demais trimestres. A função que utilizaremos é a `case_when()` do pacote `{dplyr}`.\n\n- Começo: [Fevereiro de 2020](https://bvsms.saude.gov.br/bvs/saudelegis/gm/2020/prt0188_04_02_2020.html)\n- Final: [Abril de 2022](https://bvsms.saude.gov.br/bvs/saudelegis/gm/2022/prt0913_22_04_2022.html)\n\n```{r}\ndados_com_dummy <- dados_com_trimestre |> \n  mutate(\n    periodo_pandemia = case_when(\n    trimestre_codigo %in% c(\"202001\", \"202002\", \"202003\", \"202004\",\n                            \"202101\", \"202102\", \"202103\", \"202104\",\n                            \"202201\") ~ 1, # <1>\n    .default = 0 # <2>\n  ))\n```\n1. Caso o `trimestre_codigo` sejam um dos listados dentro do vetor, queremos salvar o valor `1` na coluna `periodo_pandemia`.\n2. O valor padrão é `0`. Se nenhuma regra listada contemplar alguma linha, a coluna criada (`periodo_pandemia`) receberá o valor padrão (`0`). Ou seja, as linhas cujo período que não estão no vetor listado receberão o valor `0`. \n\n\n## Ordenando as linhas (`arrange()`)\n\nA base atual está ordada por trimestre e código da unidade da federação. Para facilitar a análise, podemos ordenar as linhas segundo a proporção de desocupação calculada no passo anterior, usando a função `arrange()`:\n\n```{r}\ndados_com_dummy |>\n  select(trimestre_codigo, uf, perc_desocupacao) |> # <1>\n  arrange(perc_desocupacao) # <2>\n```\n1. Selecionando colunas relevantes, para facilitar ver o resultado\n2. Ordenar linhas usando a coluna `perc_desocupacao`, de forma crescente\n\n\nA função `arrange()` ordena, por padrão, de forma crescente. Podemos ordenar de forma decrescente, utilizando a função `desc()` junto à coluna que queremos ordenar de forma decrescente:\n\n```{r}\ndados_com_dummy |>\n  select(trimestre_codigo, uf, perc_desocupacao) |> # <1>\n  arrange(desc(perc_desocupacao)) # <2>\n```\n1. Selecionando colunas relevantes, para facilitar ver o resultado\n2. Ordenar linhas usando a coluna `perc_desocupacao`, de forma decrescente\n\n\nNesse caso, as linhas ficaram ordenadas de forma decrescente, de acordo com a proporção de desocupação. Porém os trimestres não estão ordenados! A função `arrange()` permite que ordenemos por mais de uma coluna, e a ordem de prioridade é dada pela ordem em que as colunas são passadas para a função:\n\n```{r}\ndados_ordenados <- dados_com_dummy |> \n  arrange(\n  # colunas que queremos usar ordenar\n  trimestre_codigo, desc(prop_desocupacao)\n)\n\nglimpse(dados_ordenados)\n```\n\nAgora temos a base de dados ordenada por trimestre, e dentro de cada trimestre, por proporção de desocupação (de forma descrecente).\n\n\n## Unindo duas bases de dados (`left_join()`)\n\nUnir duas tabelas é algo comum em análises de dados. Usamos operações do tipo *join* para combinar duas tabelas, utilizando uma ou mais colunas como \"chave\". As colunas do tipo chave têm valores comuns nas duas tabelas e são usadas para identificar as linhas correspondentes entre elas.\n\nO  pacote `{dplyr}` fornece um conjunto de funções para realizar diferentes tipos de uniões, como `left_join()`, `inner_join()`, `full_join()`, entre outras.\n\nA função `left_join()` é a mais frequentemente usada: ela mantém todas as linhas da primeira tabela e adiciona colunas da segunda tabela onde houver correspondência.\n\n### Exemplo 1: Introdutório\n\nA base de dados que temos apresenta o nome e o código da UF, mas seria interessante ter a região, para futuramente usar essa variável em análises. \n\nA base de dados importada abaixo é um arquivo `.csv` preparado com as informações necessárias:\n\n```{r}\nuf_regiao <- readr::read_csv(\"https://raw.githubusercontent.com/ipeadata-lab/curso_r_intro_202409/refs/heads/main/dados/uf_regiao.csv\")\n```\n\nVamos verificar a estrutura da base de dados `uf_regiao`:\n```{r}\nglimpse(uf_regiao)\n```\nPodemos tentar unir as tabelas, sem informar a chave. Quando não informamos a chave, a função buscará os **nomes de colunas em comum** para utilizar essas colunas como chave:\n\n```{r}\n#| error: true\ndados_ordenados |> \n  left_join(uf_regiao, by = \"uf_codigo\")\n```\n\nNo exemplo acima, a função `left_join()` tentou unir as tabelas com a coluna `uf_codigo`, presente nas duas tabelas. \n\nPorém essas colunas apresentam tipos diferentes (fator e numérico). Precisamos deixá-las com o mesmo tipo para que a função `left_join()` consiga fazer a união corretamente. Vamos então transformar a coluna `uf_codigo` da tabela `uf_regiao` em fator:\n\n```{r}\nuf_regiao_fct <- uf_regiao |> \n  mutate(uf_codigo = as.factor(uf_codigo)) \n```\n\nAgora podemos unir as tabelas `dados_ordenados` e `uf_regiao_fct`:\n\n```{r}\ndados_com_regiao <- dados_ordenados |>\n  left_join(uf_regiao_fct, by = \"uf_codigo\") |> # <1>\n  relocate(uf_sigla, regiao, .after = uf_codigo) # <2>\n```\n1. Unindo a tabela `dados ordenados` e `uf_regiao_fct` usando como chave a coluna `uf_codigo`.\n2. Mover as colunas `uf_sigla` e `regiao` para após a coluna `uf_codigo`.\n\nA nova tabela `dados_com_regiao` contém as colunas de uf_sigla e regiao, que foram adicionadas a partir da tabela `uf_regiao_fct`:\n\n```{r}\nglimpse(dados_com_regiao)\n```\n\n\n### Exemplo 2: Intermediário\n\nUm exemplo comum de uso é quando temos dados por município ou estado, e desejamos visualizar esses dados em um mapa. Para isso, precisamos de informações geoespaciais, como a delimitação geográfica de cada município ou estado. Podemos usar o `left_join()` para combinar esses dados geoespaciais com os dados que queremos visualizar.\n\nVamos usar o pacote `{geobr}` para carregar as geometrias dos estados brasileiros.\n\n::: callout-tip\nO pacote `{geobr}` facilita o acesso a dados geoespaciais do Brasil, como estados, municípios e outras divisões administrativas. Ele é muito útil quando queremos fazer análises geoespaciais, já que oferece dados geográficos prontos para uso.\n\nPodemos utilizar a função `read_state()` para carregar as geometrias dos estados brasileiros. Isso nos permite combinar essas geometrias com outros dados, como taxas de desocupação, e criar mapas que facilitam a visualização de padrões regionais.\n:::\n\nCaso não tenha instalado anteriormente o pacote `{geobr}`, você pode instalar com o comando abaixo:\n\n```{r}\n#| eval: false\ninstall.packages(\"geobr\")\n```\n\n\n```{r}\n#| message: false\ngeo_estados <- geobr::read_state(showProgress = FALSE)\nglimpse(geo_estados)\n```\n\n\nO `left_join()` é usado aqui para combinar os dados do SIDRA com os dados das delimitações das UFs. Cada linha do nosso dataset de desocupação será associada à respectiva geometria da UF, permitindo visualizarmos as proporções de desocupação por UF em um mapa. Esse tipo de operação é comum quando queremos identificar padrões regionais.\n\n\nÉ importante garantir que as colunas usadas na combinação de tabelas (o argumento `by` do `left_join()`) tenham o mesmo tipo de dado. Podemos verificar o tipo de dado de cada coluna com a função `class()`:\n\n```{r}\nclass(geo_estados$code_state)\nclass(dados_com_regiao$uf_codigo)\n```\n\nNeste caso, as colunas que queremos usar como chave são de tipos diferentes (numérico e fator), O `left_join()` não conseguirá fazer a correspondência corretamente, e a função gerará um erro:\n\n```{r}\n#| error: true\nleft_join(geo_estados, dados_com_regiao, by = join_by(code_state == uf_codigo))\n```\n\nNo exemplo, podemos transformar a coluna `code_state` em fator usando `mutate()`. Assim, garantimos que as colunas usadas no argumento `by` sejam do mesmo tipo e possam ser corretamente combinados.\n\n```{r}\ndados_geo <- geo_estados |> \n  mutate(code_state = as.factor(code_state)) |> \n  left_join(dados_com_regiao, by = join_by(code_state == uf_codigo))\n\nglimpse(dados_geo)\n```\n\nAgora temos uma base de dados que combina os dados do SIDRA com as geometrias dos estados brasileiros.\n\nCombinar dados dessa forma nos permite fazer visualizações geoespaciais, como um mapa de calor das taxas de desocupação por estado. Isso facilita a identificação de padrões regionais, ajudando na interpretação dos dados.\n\nNão falaremos nesse momento sobre como criar visualizações e mapas, pois isso será abordado em aulas futuras. Mas podemos adiantar um exemplo de como criar um mapa apresentando as proporções de desocupação por estado:\n\n```{r}\n#| label: geobr-mapa\n#| echo: true\n#| code-fold: true\nlibrary(ggplot2)\ndados_geo |> \n  filter(trimestre_codigo == \"202402\") |>\n  ggplot() +\n  geom_sf(aes(fill = perc_desocupacao)) +\n  theme_light() +\n  scale_fill_viridis_c() +\n  labs(title = \"Percentual de desocupação por UF no 2º trimestre de 2024\",\n       fill = \"Desocupação (%)\") +\n  theme(legend.position = \"bottom\")\n```\n\n\n## Salvando a base de dados preparada\n\nPor fim, podemos salvar a base de dados preparada para usar nas próximas etapas. Assim não precisamos repetir todo o processo de limpeza e transformação de dados a cada vez que quisermos fazer uma análise.\n\nÉ recomendável salvar a base de dados em um formato que preserve a estrutura dos dados, como `.rds`.\n\n```{r}\n#| eval: false\n# Salvando os dados preparados\nreadr::write_rds(dados_com_regiao, \"dados_output/sidra_4092_arrumado.rds\")\n```\n\n## Exercícios sugeridos\n\nUtilizando a base de dados que criamos nessa aula (com a taxa de desocupação calculada), responda as perguntas abaixo.\n\n```{r}\n#| echo: false\ndados <- readr::read_rds(\"dados_output/sidra_4092_arrumado.rds\")\n```\n\n1. Crie uma nova tabela com apenas as colunas `uf`, `trimestre`, `perc_desocupacao` e `periodo_pandemia`. \n\n::: {.callout-tip collapse=\"true\"}\n## Dica 1\n\nO resultado esperado é:\n\n```{r}\n#| echo: false\ndados |> \n  select(uf, trimestre, perc_desocupacao, periodo_pandemia) \n```\n:::\n\n2. Qual foi a combinação de Estado/Trimestre que teve a maior taxa de desocupação...\n  - a) Durante a pandemia?\n  - b) Fora do período de pandemia?\n  \n::: {.callout-tip collapse=\"true\"}\n## Dica 1\n\nPara cada pergunta (durante ou fora do período de pandemia), precisamos fazer dois filtros:\n\n  - 1) Filtrar as linhas que correspondem ao período de pandemia (ou fora dele)\n\n  - 2) Filtrar a linha com a maior taxa de desocupação\n\n:::\n\n\n::: {.callout-tip collapse=\"true\"}\n## Dica 2\n\nPara buscar o maior valor de uma coluna, podemos usar a função `max()`. \n\nPor exemplo: o código abaixo retorna a linha com o personagem de Star Wars com o maior valor de massa (`mass`). Nesse caso, precisamos usar o argumento `na.rm = TRUE` para ignorar valores `NA`, pois a coluna `mass` tem valores faltantes.\n\n```{r}\nstarwars |> \n  filter(mass == max(mass, na.rm = TRUE))\n```\n:::\n\n::: {.callout-tip collapse=\"true\"}\n## Dica 3\n\nO resultado esperado é:\n\n```{r}\n#| echo: false\ndados |> \n  select(uf, trimestre, perc_desocupacao, periodo_pandemia) |> \n  filter(periodo_pandemia == 1) |> \n  filter(perc_desocupacao == max(perc_desocupacao)) |> \n  knitr::kable()\n```\n:::\n  \n3. Considerando o trimestre mais recente disponível, qual é o estado com a maior taxa de desocupação? E a maior?\n\n::: {.callout-tip collapse=\"true\"}\n## Dica 1\n\nPara cada pergunta (durante ou fora do período de pandemia), precisamos fazer dois filtros:\n\n  - 1) Filtrar as linhas que correspondem ao trimestre mais recente\n\n  - 2) Filtrar a linha com a maior **OU** menor taxa de desocupação\n  \n:::\n\n::: {.callout-tip collapse=\"true\"}\n## Dica 2\n\nPodemos fazer o filtro usando o operador **OU** (`|`), para filtrar as linhas que correspondem ao estado com a maior OU menor taxa de desocupação.\n\nPor exemplo:  o código abaixo retorna a linha com o personagem de Star Wars com o maior e o menor valor de massa (`mass`). Nesse caso, precisamos usar o argumento `na.rm = TRUE` para ignorar valores `NA`, pois a coluna `mass` tem valores faltantes.\n\n```{r}\nstarwars |> \n  filter(mass == max(mass, na.rm = TRUE) | mass == min(mass, na.rm = TRUE))\n```\n  \n:::\n\n\n\n::: {.callout-tip collapse=\"true\"}\n## Dica 3\n\nO resultado esperado é:\n\n```{r}\n#| echo: false\ndados |> \n  select(uf, trimestre, perc_desocupacao) |> \n  filter(trimestre == \"2º trimestre 2024\") |> \n  filter(perc_desocupacao == max(perc_desocupacao) | perc_desocupacao == min(perc_desocupacao)) |> \n  knitr::kable()\n```\n:::\n\n\n\n4. Considerando o trimestre mais recente disponível, quais são os 5 estados com as maiores taxas de desocupação?\n\n::: {.callout-tip collapse=\"true\"}\n## Dica 1\n\nA função `head()` retorna as primeiras linhas de um data frame. Podemos usar essa função para retornar as primeiras linhas de um data frame ordenado, usando o número de linhas desejadas como argumento:\n\n```{r}\n#| echo: false\nstarwars |> \n  arrange(desc(mass)) |> \n  head(5) \n```\n:::\n\n::: {.callout-tip collapse=\"true\"}\n## Dica 2\n\nO resultado esperado é:\n\n```{r}\n#| echo: false\ndados |> \n  select(uf, trimestre, perc_desocupacao) |> \n  filter(trimestre == \"2º trimestre 2024\") |> \n  arrange(desc(perc_desocupacao)) |>\n  head(5) |> \n  knitr::kable()\n```\n:::\n\n5. Utilizando a função `tidyr::pivot_wider()`, como podemos criar uma tabela onde cada linha apresente dados de um estado, e cada trimestre esteja em uma coluna preenchida com os valores de percentual de desocupação?\n\n\nVeja o exemplo abaixo:\n\n```{r}\n#| echo: false\ndados |>\n  select(uf, trimestre, perc_desocupacao) |> \n  tidyr::pivot_wider(names_from = trimestre, values_from = perc_desocupacao) |> \n  knitr::kable()\n```\n\n::: {.callout-tip collapse=\"true\"}\n\n### Dica 1\n\nPara usar a função `pivot_wider()`, precisamos indicar os argumentos `names_from` e `values_from`.\n\nO argumento `names_from` é a coluna que queremos usar para nomear as novas colunas. No caso, queremos que cada opção de trimestre seja uma nova coluna.\n\nO argumento `values_from` é a coluna que queremos usar para preencher os valores das novas colunas. No caso, queremos preencher as novas colunas com a taxa de desocupação.\n:::\n\n\n\n\n## Sugestões de materiais\n\n- Livro [R para Ciência de Dados 2ed](https://cienciadedatos.github.io/pt-r4ds/):\n  - [Transformação de dados](https://cienciadedatos.github.io/pt-r4ds/data-transform.html)\n  - [Organização de dados](https://cienciadedatos.github.io/pt-r4ds/data-tidy.html)\n  \n","srcMarkdownNoYaml":"\n\n## Introdução\n\nPrimeiramente, precisamos carregar o pacote `tidyverse` e a base de dados que vamos utilizar. A base de dados é a tabela 4092 do SIDRA, que apresenta dados sobre \"pessoas de 14 anos ou mais de idade por condição em relação à força de trabalho e condição de ocupação\"[^transformacao-dados], e foi baixada previamente (em [Importando dados](03_importacao.html#pacote-sidrar)).\n\n[^transformacao-dados]: É interessante conhecer mais sobre a base de dados que estamos utilizando. O IBGE apresenta alguns conteúdos interessantes, como a página com informações sobre a [PNAD Contínua Trimestral](https://www.ibge.gov.br/estatisticas/sociais/trabalho/9173-pesquisa-nacional-por-amostra-de-domicilios-continua-trimestral.html?edicao=41004), e também a [página sobre desemprego](https://www.ibge.gov.br/explica/desemprego.php) que nos ajuda a entender as variáveis presentes.\n\n\nNeste capítulo, vamos explorar as funções de transformação de dados do pacote `dplyr`, a partir da pergunta norteadora abaixo:\n\n> Considerando que a tabela 4092 apresenta dados sobre \"pessoas de 14 anos ou mais de idade por condição em relação à força de trabalho e condição de ocupação\", **qual é a taxa de desocupação de cada estado e região do Brasil ao longo do tempo?**\n\n\n```{r}\n#| message: false\nlibrary(dplyr)\ndados_brutos <- readr::read_rds(\"dados/sidrar_4092_bruto.rds\") \n```\n\n\n## Linhas, colunas e objetivo de análise\n\nUma pergunta que é sempre importante ter em mente ao analisar dados é: O que cada linha representa? Na estatística, esse é o conceito da **unidade observacional**.\n\nO objeto `dados_brutos` apresenta uma linha para cada combinação das seguintes variáveis:\n\n  - `Trimestre (Código)` / `Trimestre`\n\n  - `Unidade da Federação` / `Unidade da Federação (Código)`\n\n  - `Variável` / `Variável (Código)`\n  \n  - `Condição em relação à força de trabalho e condição de ocupação` e `Condição em relação à força de trabalho e condição de ocupação (Código)`\n\nPodemos consultar os valores distintos possíveis no R, para garantir que estamos selecionando corretamente os valores de interesse.\n\nAs variáveis disponíveis na base de dados, e suas unidades de medida são:\n\n```{r}\ndados_brutos |>\n  distinct(`Variável`, `Unidade de Medida`) # <1>\n```\n1. Colunas que queremos buscar os valores distintos\n\nPodemos observar, cada linha representa uma combinação de trimestre, unidade da federação e variável. \n\nOutras perguntas relevantes ao analisar dados são:\n\n  - Qual é a pergunta que eu quero responder com esses dados?\n  - Quais são as variáveis que eu preciso para responder essa pergunta?\n\n\n## Padronizar nome das colunas\n\nÉ uma boa prática padronizar o nome das colunas de um data frame. Assim evitamos problemas de codificação de caracteres (*encoding*), facilitamos a legibilidade do código e evitamos possíveis erros ao acessar as colunas.\n\nO pacote `janitor` possui a função `clean_names()`, que padroniza os nomes das colunas de um *data frame*. Ele substitui espaços por *underline* (`_`), remove caracteres especiais, e transforma o texto em minúsculo, garantindo maior consistência ao lidar com os dados. Isso evita erros ao acessar colunas.\n\n```{r}\nnames(dados_brutos) # <1>\n```\n1. Checar o nome das colunas da base de dados\n\n\n```{r}\ndados_renomeados <- janitor::clean_names(dados_brutos)  # <1>\n\nnames(dados_renomeados)  # <2>\n```\n1. Limpar nomes das colunas da base de dados, e salvar em um novo objeto chamado `dados_renomeados`\n2. Checar o nome das colunas da base de dados renomeada\n\n\n## Pipe - Encadeando funções\n\nNos exemplos anteriores, utilizamos uma função por vez, para facilitar a compreensão de cada etapa. No entanto, à medida que nos familiarizamos com as funções, podemos encadear várias delas em um único fluxo de código usando o operador *pipe* (`%>%` ou `|>`). Isso torna o código mais conciso e elimina a criação de objetos intermediários desnecessários.\n\nPorém, é importante ter cuidado para não criar sequências muito longas e difíceis de entender.\n\n\n## Filtrando linhas (`filter()`)\n\nPara responder à pergunta norteadora, não precisamos de todas as variáveis presentes na base de dados. Podemos **filtrar** as linhas que são relevantes para a análise, escolhendo as variáveis de interesse.\n\nNesse caso, podemos filtrar os dados onde a variável é igual à `\"Pessoas de 14 anos ou mais de idade\"`.\n\n```{r}\ndados_filtrados <- dados_renomeados |>\n  filter(variavel == \"Pessoas de 14 anos ou mais de idade\")\n```\n\n\nPara verificar se o filtro foi feito corretamente, podemos checar o número de linhas de cada base de dados:\n\n```{r}\nnrow(dados_renomeados)\nnrow(dados_filtrados)\n```\n\nPodemos verificar também os valores distintos para as colunas `variavel` e `unidade_de_medida` na base de dados `dados_filtrados`:\n\n```{r}\ndados_filtrados |>\n  distinct(variavel, unidade_de_medida)\n```\n\nAgora sabemos que a base de dados `dados_filtrados` contém apenas dados sobre a variável `\"Pessoas de 14 anos ou mais de idade\"`, e que a unidade de medida da coluna `valor` é mil pessoas.\n\n::: callout-tip\n## Várias formas de filtrar as linhas\nComo citamos anteriormente, em algumas situações existem várias formas diferentes de realizar uma tarefa.\n\nNo caso da função `filter()`, podemos utilizar diferentes operadores lógicos ou funções auxiliares para fazer filtros.\n\nOs exemplos abaixo podem ser úteis para consulta futura!\n\nPara esses exemplos, vamos utilizar a tabela `starwars` do pacote `dplyr`. Nessa tabela, cada linha representa um personagem de Star Wars, e as colunas representam diferentes características desses personagens.\n\n#### Exemplos de operadores lógicos:\n\n| Operador | Descrição | Exemplo | Interpretação |\n|----|-------|--------|-----------|\n| `==`     | Igual à  | `species == \"Human\"` | Todas as linhas cuja espécie é \"Human\" |\n| `!=`     | Diferente de | `species != \"Human\"` | Todas as linhas cuja espécie **não é** \"Human\"|\n| `>`      | Maior que | `height > 180` | Todas as linhas cuja altura é maior que 180 |\n| `>=`     | Maior ou igual a | `height >= 180` | Todas as linhas cuja altura é maior ou igual a 180 |\n| `<`      | Menor que | `height < 180` | Todas as linhas cuja altura é menor que 180 |\n| `<=`     | Menor ou igual a | `height <= 180` | Todas as linhas cuja altura é menor ou igual a 180 |\n| `%in%`   | Está em um conjunto | `species %in% c(\"Human\", \"Droid\")` | Todas as linhas cuja espécie é \"Human\" ou \"Droid\" |\n| `!`      | Negação | `!is.na(height)` | Todas as linhas cuja altura **não é** `NA` |\n|`!` e `%in%` | Negação de um conjunto | `!(species %in% c(\"Human\", \"Droid\"))` | Todas as linhas cuja espécie **não é** \"Human\" ou \"Droid\" |\n\n#### Exemplos de funções auxiliares:\n\n| Função | Descrição | Exemplo | Interpretação |\n|----|-------|--------|-----------|\n| `str_detect()` | Detecta padrões em textos | `str_detect(name, \"Skywalker\")` | Todas as linhas cujo nome contém \"Skywalker\" |\n| `str_starts()` | Detecta padrões no início de textos | `str_starts(name, \"Luke\")` | Todas as linhas cujo nome começa com \"Luke\" |\n| `str_ends()` | Detecta padrões no final de textos | `str_ends(name, \"Vader\")` | Todas as linhas cujo nome termina com \"Vader\" |\n:::\n\n\n## Selecionando colunas (`select()`)\n\nAlgumas colunas não são relevantes para responder à pergunta norteadora. Podemos **selecionar** apenas as colunas que vamos utilizar através da função `select()`:\n\n```{r}\ndados_selecionados <-\n  dados_filtrados |>\n  select(\n    # colunas que queremos manter\n    unidade_da_federacao,\n    unidade_da_federacao_codigo,\n    trimestre,\n    trimestre_codigo,\n    condicao_em_relacao_a_forca_de_trabalho_e_condicao_de_ocupacao,\n    valor\n  )\n\nglimpse(dados_selecionados)\n```\n\n\n::: callout-tip\n## Várias formas de selecionar colunas\n\nOs exemplos abaixo podem ser úteis para consulta futura!\n\nPara esses exemplos, vamos utilizar a tabela `starwars` do pacote `dplyr`:\n\n#### Exemplos de seleção de colunas:\n| Operador | Descrição | Exemplo | Interpretação |\n|----|-------|--------|-----------|\n| `:` | Seleciona um intervalo de colunas | `name:mass` | Todas as colunas entre `name` e `mass` |\n| `c()` | Seleciona colunas específicas | `c(name, height, mass)` | Apenas as colunas `name`, `height` e `mass` |\n| `-c()` | Exclui colunas específicas | `-c(name, height, mass)` | Todas as colunas, exceto `name`, `height` e `mass` |\n\n#### Exemplos de funções auxiliares:\n| Função | Descrição | Exemplo | Interpretação |\n|----|-------|--------|-----------|\n| `starts_with()` | Seleciona colunas que começam com um prefixo | `starts_with(\"h\")` | Todas as colunas que começam com \"h\" |\n| `ends_with()` | Seleciona colunas que terminam com um sufixo | `ends_with(\"color\")` | Todas as colunas que terminam com \"color\" |\n| `contains()` | Seleciona colunas que contêm um padrão | `contains(\"e\")` | Todas as colunas que contêm \"e\" |\n:::\n\n\n\n## Renomeando colunas (`rename()`)\n\nPodemos renomear colunas com a função `rename()`. Vamos renomear algumas colunas para facilitar o uso posteriormente:\n\n```{r}\ndados_renomeados_2 <- dados_selecionados |>\n  rename(\n    # colunas que queremos renomear: novo_nome = nome_atual\n    condicao = condicao_em_relacao_a_forca_de_trabalho_e_condicao_de_ocupacao,\n    valor_mil_pessoas = valor,\n    uf = unidade_da_federacao,\n    uf_codigo = unidade_da_federacao_codigo\n  )\n\nglimpse(dados_renomeados_2)\n```\n\n\n\n\n\n## Transformando a estrutura da tabela (`pivot_wider()` e `pivot_longer()`)\n\nAinda considerando nossa pergunta norteadora, queremos calcular a taxa de desocupação de cada estado e região do Brasil ao longo do tempo. Para isso, é mais fácil trabalhar com a tabela onde cada linha represente uma UF por trimestre, e as categorias da variável `condicao` sejam transformadas em colunas. \n\nPara fazer essa transformação, podemos usar a função `pivot_wider()`, do pacote `{tidyr}`.\n\nA função `pivot_wider()` é útil quando queremos reorganizar uma tabela, transformando variáveis categóricas em novas colunas. Essa estrutura facilita cálculos comparativos e análises entre as diferentes categorias.\n\nPor exemplo, no formato atual (dados longos), temos uma linha para cada combinação de UF, trimestre e condição de ocupação. Ao usarmos `pivot_wider()`, vamos transformar a tabela para que cada linha represente uma UF por trimestre, e as diferentes condições de ocupação (empregado, desocupado, etc.) se tornem colunas.\n\n```{r}\ndados_largos <- dados_renomeados_2 |> \n  tidyr::pivot_wider(\n  names_from = condicao, # <1>\n  values_from = valor_mil_pessoas, # <2>\n  names_prefix = \"mil_pessoas_\" # <3>\n)\n```\n1. `names_from = `: Nome da coluna de onde os **nomes** das novas colunas serão extraídos\n2. `values_from = `: Nome da coluna de onde os **valores** para preencher as novas colunas serão extraídos \n3. `names_prefix = `: Podemos adicionar um texto como prefixo. Nesse caso, isso é opcional, mas é útil para ficar claro qual é a unidade de medida das variáveis.\n\n\n```{r}\nglimpse(dados_largos)\n```\n\nAgora temos uma tabela onde cada linha representa uma UF por trimestre, e as categorias da variável `condicao` se tornaram colunas. Porém agora temos colunas com nomes que estão com caracteres especiais, e podemos arrumar isso com a função `clean_names()`.\n\n```{r}\ndados_largos_renomeados <- janitor::clean_names(dados_largos)\nglimpse(dados_largos_renomeados)\n```\n\n::: callout-info\nAs funções `pivot_longer()` e `pivot_wider()` são usadas para alternar entre dados 'longos' e 'largos'. Normalmente, dados longos são mais fáceis de visualizar, enquanto dados largos são melhores para realizar cálculos comparativos entre categorias. Para cada análise, sempre existe um formato mais apropriado a considerar.\n:::\n\n\n## Criando e transformando colunas (`mutate()`)\n\nPara criar novas colunas, ou transformar colunas que já existem, podemos usar a função `mutate()`.\n\n### Alterando os tipos de variáveis\n\nA variável `uf_codigo` está armazenada como valor numérico. No entanto, como não realizaremos operações matemáticas com esses valores, é mais apropriado transformá-los em fatores, o que facilita a análise e previne erros em cálculos futuros.\n\nExistem várias funções para transformar variáveis de um tipo para outro, como `as.factor()`, `as.character()`, `as.numeric()`, `as.Date()`,  etc.\n\n```{r}\ndados_tipo <- dados_largos_renomeados |>\n  mutate(\n    # nova variável:\n    # nome_da_coluna = o que queremos calcular\n    uf_codigo = as.factor(uf_codigo)\n    )\n```\n\n### Calculando a taxa de desocupação\n\nPara calcular a taxa de desocupação, precisamos criar uma nova variável representando a proporção de pessoas desocupadas em relação ao total de pessoas economicamente ativas.\n\n```{r}\ndados_com_proporcao <- dados_tipo |>\n  mutate(\n    prop_desocupacao = mil_pessoas_forca_de_trabalho_desocupada / mil_pessoas_forca_de_trabalho, # <1>\n    perc_desocupacao = prop_desocupacao * 100 # <2>\n  )\n```\n1. Calculando a proporção da desocupação: para cada linha, vamos dividir o valor `mil_pessoas_forca_de_trabalho_desocupada` por `mil_pessoas_forca_de_trabalho`. \n2. Multiplicando por 100 para transformar em percentual.\n\n\n### Criando uma variável **trimestre_inicio**\n\nPodemos criar uma nova variável chamada `trimestre_inicio` para  representar a data de início de cada trimestre. Para isso, precisaremos criar algumas outras variáveis \"auxiliares\" a partir da variável `trimestre_codigo`: `ano`, `trimestre_numero` e `trimestre_mes_inicio`.\n\n```{r}\ndados_com_trimestre <- dados_com_proporcao |>\n  mutate(\n    ano = stringr::str_sub(trimestre_codigo, 1, 4), # <1>\n    ano = as.numeric(ano), # <2>\n    \n    trimestre_numero = stringr::str_sub(trimestre_codigo, 5, 6),  # <3>\n    trimestre_numero = as.numeric(trimestre_numero), # <4>\n    \n    trimestre_mes_inicio = case_when( # <5>\n      trimestre_numero == 1 ~ 1,\n      trimestre_numero == 2 ~ 4,\n      trimestre_numero == 3 ~ 7,\n      trimestre_numero == 4 ~ 10\n    ),\n    \n    trimestre_inicio = paste0(ano, \"-\", trimestre_mes_inicio, \"-01\"),  # <6>\n    trimestre_inicio = as.Date(trimestre_inicio),  # <7>\n    \n    .after = trimestre_codigo # <8>\n  ) |> \n  select(-trimestre_mes_inicio, -trimestre_numero) # <9>\n```\n1. Extrair os 4 primeiros caracteres do código do trimestre\n2. Convertendo a coluna `ano` de texto para numérico\n3. Extrair os 2 últimos caracteres do código do trimestre\n4. Convertendo a coluna `trimestre_numero` de texto para numérico\n5. Criar variável com o mês de início do trimestre\n6. Criar variável com data de início do trimestre (neste momento, com tipo texto), colando os valores do mês e ano.\n7. Convertendo a coluna `trimestre_inicio` de texto para Data\n8. Queremos adicionar as colunas novas após a coluna `trimestre_codigo`\n9. Removendo colunas que não serão necessárias\n\n\n### Criando uma variável *dummy*\n\nUma variável *dummy* é uma variável binária que indica a presença ou ausência de algum atributo.\n\nPodemos criar uma variável dummy para identificar os trimestres que ocorreram durante o período de emergência em saúde pública de importância nacional de COVID-19. Para isso, vamos criar uma nova variável chamada `periodo_pandemia`, que será `1` para os trimestres que ocorreram durante a pandemia, e `0` para os demais trimestres. A função que utilizaremos é a `case_when()` do pacote `{dplyr}`.\n\n- Começo: [Fevereiro de 2020](https://bvsms.saude.gov.br/bvs/saudelegis/gm/2020/prt0188_04_02_2020.html)\n- Final: [Abril de 2022](https://bvsms.saude.gov.br/bvs/saudelegis/gm/2022/prt0913_22_04_2022.html)\n\n```{r}\ndados_com_dummy <- dados_com_trimestre |> \n  mutate(\n    periodo_pandemia = case_when(\n    trimestre_codigo %in% c(\"202001\", \"202002\", \"202003\", \"202004\",\n                            \"202101\", \"202102\", \"202103\", \"202104\",\n                            \"202201\") ~ 1, # <1>\n    .default = 0 # <2>\n  ))\n```\n1. Caso o `trimestre_codigo` sejam um dos listados dentro do vetor, queremos salvar o valor `1` na coluna `periodo_pandemia`.\n2. O valor padrão é `0`. Se nenhuma regra listada contemplar alguma linha, a coluna criada (`periodo_pandemia`) receberá o valor padrão (`0`). Ou seja, as linhas cujo período que não estão no vetor listado receberão o valor `0`. \n\n\n## Ordenando as linhas (`arrange()`)\n\nA base atual está ordada por trimestre e código da unidade da federação. Para facilitar a análise, podemos ordenar as linhas segundo a proporção de desocupação calculada no passo anterior, usando a função `arrange()`:\n\n```{r}\ndados_com_dummy |>\n  select(trimestre_codigo, uf, perc_desocupacao) |> # <1>\n  arrange(perc_desocupacao) # <2>\n```\n1. Selecionando colunas relevantes, para facilitar ver o resultado\n2. Ordenar linhas usando a coluna `perc_desocupacao`, de forma crescente\n\n\nA função `arrange()` ordena, por padrão, de forma crescente. Podemos ordenar de forma decrescente, utilizando a função `desc()` junto à coluna que queremos ordenar de forma decrescente:\n\n```{r}\ndados_com_dummy |>\n  select(trimestre_codigo, uf, perc_desocupacao) |> # <1>\n  arrange(desc(perc_desocupacao)) # <2>\n```\n1. Selecionando colunas relevantes, para facilitar ver o resultado\n2. Ordenar linhas usando a coluna `perc_desocupacao`, de forma decrescente\n\n\nNesse caso, as linhas ficaram ordenadas de forma decrescente, de acordo com a proporção de desocupação. Porém os trimestres não estão ordenados! A função `arrange()` permite que ordenemos por mais de uma coluna, e a ordem de prioridade é dada pela ordem em que as colunas são passadas para a função:\n\n```{r}\ndados_ordenados <- dados_com_dummy |> \n  arrange(\n  # colunas que queremos usar ordenar\n  trimestre_codigo, desc(prop_desocupacao)\n)\n\nglimpse(dados_ordenados)\n```\n\nAgora temos a base de dados ordenada por trimestre, e dentro de cada trimestre, por proporção de desocupação (de forma descrecente).\n\n\n## Unindo duas bases de dados (`left_join()`)\n\nUnir duas tabelas é algo comum em análises de dados. Usamos operações do tipo *join* para combinar duas tabelas, utilizando uma ou mais colunas como \"chave\". As colunas do tipo chave têm valores comuns nas duas tabelas e são usadas para identificar as linhas correspondentes entre elas.\n\nO  pacote `{dplyr}` fornece um conjunto de funções para realizar diferentes tipos de uniões, como `left_join()`, `inner_join()`, `full_join()`, entre outras.\n\nA função `left_join()` é a mais frequentemente usada: ela mantém todas as linhas da primeira tabela e adiciona colunas da segunda tabela onde houver correspondência.\n\n### Exemplo 1: Introdutório\n\nA base de dados que temos apresenta o nome e o código da UF, mas seria interessante ter a região, para futuramente usar essa variável em análises. \n\nA base de dados importada abaixo é um arquivo `.csv` preparado com as informações necessárias:\n\n```{r}\nuf_regiao <- readr::read_csv(\"https://raw.githubusercontent.com/ipeadata-lab/curso_r_intro_202409/refs/heads/main/dados/uf_regiao.csv\")\n```\n\nVamos verificar a estrutura da base de dados `uf_regiao`:\n```{r}\nglimpse(uf_regiao)\n```\nPodemos tentar unir as tabelas, sem informar a chave. Quando não informamos a chave, a função buscará os **nomes de colunas em comum** para utilizar essas colunas como chave:\n\n```{r}\n#| error: true\ndados_ordenados |> \n  left_join(uf_regiao, by = \"uf_codigo\")\n```\n\nNo exemplo acima, a função `left_join()` tentou unir as tabelas com a coluna `uf_codigo`, presente nas duas tabelas. \n\nPorém essas colunas apresentam tipos diferentes (fator e numérico). Precisamos deixá-las com o mesmo tipo para que a função `left_join()` consiga fazer a união corretamente. Vamos então transformar a coluna `uf_codigo` da tabela `uf_regiao` em fator:\n\n```{r}\nuf_regiao_fct <- uf_regiao |> \n  mutate(uf_codigo = as.factor(uf_codigo)) \n```\n\nAgora podemos unir as tabelas `dados_ordenados` e `uf_regiao_fct`:\n\n```{r}\ndados_com_regiao <- dados_ordenados |>\n  left_join(uf_regiao_fct, by = \"uf_codigo\") |> # <1>\n  relocate(uf_sigla, regiao, .after = uf_codigo) # <2>\n```\n1. Unindo a tabela `dados ordenados` e `uf_regiao_fct` usando como chave a coluna `uf_codigo`.\n2. Mover as colunas `uf_sigla` e `regiao` para após a coluna `uf_codigo`.\n\nA nova tabela `dados_com_regiao` contém as colunas de uf_sigla e regiao, que foram adicionadas a partir da tabela `uf_regiao_fct`:\n\n```{r}\nglimpse(dados_com_regiao)\n```\n\n\n### Exemplo 2: Intermediário\n\nUm exemplo comum de uso é quando temos dados por município ou estado, e desejamos visualizar esses dados em um mapa. Para isso, precisamos de informações geoespaciais, como a delimitação geográfica de cada município ou estado. Podemos usar o `left_join()` para combinar esses dados geoespaciais com os dados que queremos visualizar.\n\nVamos usar o pacote `{geobr}` para carregar as geometrias dos estados brasileiros.\n\n::: callout-tip\nO pacote `{geobr}` facilita o acesso a dados geoespaciais do Brasil, como estados, municípios e outras divisões administrativas. Ele é muito útil quando queremos fazer análises geoespaciais, já que oferece dados geográficos prontos para uso.\n\nPodemos utilizar a função `read_state()` para carregar as geometrias dos estados brasileiros. Isso nos permite combinar essas geometrias com outros dados, como taxas de desocupação, e criar mapas que facilitam a visualização de padrões regionais.\n:::\n\nCaso não tenha instalado anteriormente o pacote `{geobr}`, você pode instalar com o comando abaixo:\n\n```{r}\n#| eval: false\ninstall.packages(\"geobr\")\n```\n\n\n```{r}\n#| message: false\ngeo_estados <- geobr::read_state(showProgress = FALSE)\nglimpse(geo_estados)\n```\n\n\nO `left_join()` é usado aqui para combinar os dados do SIDRA com os dados das delimitações das UFs. Cada linha do nosso dataset de desocupação será associada à respectiva geometria da UF, permitindo visualizarmos as proporções de desocupação por UF em um mapa. Esse tipo de operação é comum quando queremos identificar padrões regionais.\n\n\nÉ importante garantir que as colunas usadas na combinação de tabelas (o argumento `by` do `left_join()`) tenham o mesmo tipo de dado. Podemos verificar o tipo de dado de cada coluna com a função `class()`:\n\n```{r}\nclass(geo_estados$code_state)\nclass(dados_com_regiao$uf_codigo)\n```\n\nNeste caso, as colunas que queremos usar como chave são de tipos diferentes (numérico e fator), O `left_join()` não conseguirá fazer a correspondência corretamente, e a função gerará um erro:\n\n```{r}\n#| error: true\nleft_join(geo_estados, dados_com_regiao, by = join_by(code_state == uf_codigo))\n```\n\nNo exemplo, podemos transformar a coluna `code_state` em fator usando `mutate()`. Assim, garantimos que as colunas usadas no argumento `by` sejam do mesmo tipo e possam ser corretamente combinados.\n\n```{r}\ndados_geo <- geo_estados |> \n  mutate(code_state = as.factor(code_state)) |> \n  left_join(dados_com_regiao, by = join_by(code_state == uf_codigo))\n\nglimpse(dados_geo)\n```\n\nAgora temos uma base de dados que combina os dados do SIDRA com as geometrias dos estados brasileiros.\n\nCombinar dados dessa forma nos permite fazer visualizações geoespaciais, como um mapa de calor das taxas de desocupação por estado. Isso facilita a identificação de padrões regionais, ajudando na interpretação dos dados.\n\nNão falaremos nesse momento sobre como criar visualizações e mapas, pois isso será abordado em aulas futuras. Mas podemos adiantar um exemplo de como criar um mapa apresentando as proporções de desocupação por estado:\n\n```{r}\n#| label: geobr-mapa\n#| echo: true\n#| code-fold: true\nlibrary(ggplot2)\ndados_geo |> \n  filter(trimestre_codigo == \"202402\") |>\n  ggplot() +\n  geom_sf(aes(fill = perc_desocupacao)) +\n  theme_light() +\n  scale_fill_viridis_c() +\n  labs(title = \"Percentual de desocupação por UF no 2º trimestre de 2024\",\n       fill = \"Desocupação (%)\") +\n  theme(legend.position = \"bottom\")\n```\n\n\n## Salvando a base de dados preparada\n\nPor fim, podemos salvar a base de dados preparada para usar nas próximas etapas. Assim não precisamos repetir todo o processo de limpeza e transformação de dados a cada vez que quisermos fazer uma análise.\n\nÉ recomendável salvar a base de dados em um formato que preserve a estrutura dos dados, como `.rds`.\n\n```{r}\n#| eval: false\n# Salvando os dados preparados\nreadr::write_rds(dados_com_regiao, \"dados_output/sidra_4092_arrumado.rds\")\n```\n\n## Exercícios sugeridos\n\nUtilizando a base de dados que criamos nessa aula (com a taxa de desocupação calculada), responda as perguntas abaixo.\n\n```{r}\n#| echo: false\ndados <- readr::read_rds(\"dados_output/sidra_4092_arrumado.rds\")\n```\n\n1. Crie uma nova tabela com apenas as colunas `uf`, `trimestre`, `perc_desocupacao` e `periodo_pandemia`. \n\n::: {.callout-tip collapse=\"true\"}\n## Dica 1\n\nO resultado esperado é:\n\n```{r}\n#| echo: false\ndados |> \n  select(uf, trimestre, perc_desocupacao, periodo_pandemia) \n```\n:::\n\n2. Qual foi a combinação de Estado/Trimestre que teve a maior taxa de desocupação...\n  - a) Durante a pandemia?\n  - b) Fora do período de pandemia?\n  \n::: {.callout-tip collapse=\"true\"}\n## Dica 1\n\nPara cada pergunta (durante ou fora do período de pandemia), precisamos fazer dois filtros:\n\n  - 1) Filtrar as linhas que correspondem ao período de pandemia (ou fora dele)\n\n  - 2) Filtrar a linha com a maior taxa de desocupação\n\n:::\n\n\n::: {.callout-tip collapse=\"true\"}\n## Dica 2\n\nPara buscar o maior valor de uma coluna, podemos usar a função `max()`. \n\nPor exemplo: o código abaixo retorna a linha com o personagem de Star Wars com o maior valor de massa (`mass`). Nesse caso, precisamos usar o argumento `na.rm = TRUE` para ignorar valores `NA`, pois a coluna `mass` tem valores faltantes.\n\n```{r}\nstarwars |> \n  filter(mass == max(mass, na.rm = TRUE))\n```\n:::\n\n::: {.callout-tip collapse=\"true\"}\n## Dica 3\n\nO resultado esperado é:\n\n```{r}\n#| echo: false\ndados |> \n  select(uf, trimestre, perc_desocupacao, periodo_pandemia) |> \n  filter(periodo_pandemia == 1) |> \n  filter(perc_desocupacao == max(perc_desocupacao)) |> \n  knitr::kable()\n```\n:::\n  \n3. Considerando o trimestre mais recente disponível, qual é o estado com a maior taxa de desocupação? E a maior?\n\n::: {.callout-tip collapse=\"true\"}\n## Dica 1\n\nPara cada pergunta (durante ou fora do período de pandemia), precisamos fazer dois filtros:\n\n  - 1) Filtrar as linhas que correspondem ao trimestre mais recente\n\n  - 2) Filtrar a linha com a maior **OU** menor taxa de desocupação\n  \n:::\n\n::: {.callout-tip collapse=\"true\"}\n## Dica 2\n\nPodemos fazer o filtro usando o operador **OU** (`|`), para filtrar as linhas que correspondem ao estado com a maior OU menor taxa de desocupação.\n\nPor exemplo:  o código abaixo retorna a linha com o personagem de Star Wars com o maior e o menor valor de massa (`mass`). Nesse caso, precisamos usar o argumento `na.rm = TRUE` para ignorar valores `NA`, pois a coluna `mass` tem valores faltantes.\n\n```{r}\nstarwars |> \n  filter(mass == max(mass, na.rm = TRUE) | mass == min(mass, na.rm = TRUE))\n```\n  \n:::\n\n\n\n::: {.callout-tip collapse=\"true\"}\n## Dica 3\n\nO resultado esperado é:\n\n```{r}\n#| echo: false\ndados |> \n  select(uf, trimestre, perc_desocupacao) |> \n  filter(trimestre == \"2º trimestre 2024\") |> \n  filter(perc_desocupacao == max(perc_desocupacao) | perc_desocupacao == min(perc_desocupacao)) |> \n  knitr::kable()\n```\n:::\n\n\n\n4. Considerando o trimestre mais recente disponível, quais são os 5 estados com as maiores taxas de desocupação?\n\n::: {.callout-tip collapse=\"true\"}\n## Dica 1\n\nA função `head()` retorna as primeiras linhas de um data frame. Podemos usar essa função para retornar as primeiras linhas de um data frame ordenado, usando o número de linhas desejadas como argumento:\n\n```{r}\n#| echo: false\nstarwars |> \n  arrange(desc(mass)) |> \n  head(5) \n```\n:::\n\n::: {.callout-tip collapse=\"true\"}\n## Dica 2\n\nO resultado esperado é:\n\n```{r}\n#| echo: false\ndados |> \n  select(uf, trimestre, perc_desocupacao) |> \n  filter(trimestre == \"2º trimestre 2024\") |> \n  arrange(desc(perc_desocupacao)) |>\n  head(5) |> \n  knitr::kable()\n```\n:::\n\n5. Utilizando a função `tidyr::pivot_wider()`, como podemos criar uma tabela onde cada linha apresente dados de um estado, e cada trimestre esteja em uma coluna preenchida com os valores de percentual de desocupação?\n\n\nVeja o exemplo abaixo:\n\n```{r}\n#| echo: false\ndados |>\n  select(uf, trimestre, perc_desocupacao) |> \n  tidyr::pivot_wider(names_from = trimestre, values_from = perc_desocupacao) |> \n  knitr::kable()\n```\n\n::: {.callout-tip collapse=\"true\"}\n\n### Dica 1\n\nPara usar a função `pivot_wider()`, precisamos indicar os argumentos `names_from` e `values_from`.\n\nO argumento `names_from` é a coluna que queremos usar para nomear as novas colunas. No caso, queremos que cada opção de trimestre seja uma nova coluna.\n\nO argumento `values_from` é a coluna que queremos usar para preencher os valores das novas colunas. No caso, queremos preencher as novas colunas com a taxa de desocupação.\n:::\n\n\n\n\n## Sugestões de materiais\n\n- Livro [R para Ciência de Dados 2ed](https://cienciadedatos.github.io/pt-r4ds/):\n  - [Transformação de dados](https://cienciadedatos.github.io/pt-r4ds/data-transform.html)\n  - [Organização de dados](https://cienciadedatos.github.io/pt-r4ds/data-tidy.html)\n  \n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":true,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"toc-depth":5,"output-file":"05_transformacao.html"},"language":{"toc-title-document":"Índice","toc-title-website":"Nesta página","related-formats-title":"Outros formatos","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Fonte","other-links-title":"Outros Links","code-links-title":"Ligações de código","launch-dev-container-title":"Iniciar Dev Container","launch-binder-title":"Iniciar Binder","article-notebook-label":"Caderno do Artigo","notebook-preview-download":"Baixar Caderno","notebook-preview-download-src":"Descarregar código fonte","notebook-preview-back":"Voltar ao Artigo","manuscript-meca-bundle":"Arquivo MECA","section-title-abstract":"Resumo","section-title-appendices":"Apêndices","section-title-footnotes":"Notas de rodapé","section-title-references":"Referências","section-title-reuse":"Reuso","section-title-copyright":"Direito autoral","section-title-citation":"Citação","appendix-attribution-cite-as":"Por favor, cite este trabalho como:","appendix-attribution-bibtex":"BibTeX","appendix-view-license":"Ver Licença","title-block-author-single":"Autor","title-block-author-plural":"Autores","title-block-affiliation-single":"Afiliação","title-block-affiliation-plural":"Afiliações","title-block-published":"Data de Publicação","title-block-modified":"Data de Modificação","title-block-keywords":"Palavras-chave","callout-tip-title":"Dica","callout-note-title":"Nota","callout-warning-title":"Aviso","callout-important-title":"Importante","callout-caution-title":"Cuidado","code-summary":"Código","code-tools-menu-caption":"Código","code-tools-show-all-code":"Mostrar o código","code-tools-hide-all-code":"Esconder o código","code-tools-view-source":"Ver o código fonte","code-tools-source-code":"Código fonte","tools-share":"Share","tools-download":"Download","code-line":"Linha","code-lines":"Linhas","copy-button-tooltip":"Copiar para a área de transferência","copy-button-tooltip-success":"Copiada","repo-action-links-edit":"Editar essa página","repo-action-links-source":"Ver o código fonte","repo-action-links-issue":"Criar uma issue","back-to-top":"De volta ao topo","search-no-results-text":"Nenhum resultado","search-matching-documents-text":"documentos correspondentes","search-copy-link-title":"Copiar link para a busca","search-hide-matches-text":"Esconder correspondências adicionais","search-more-match-text":"mais correspondência neste documento","search-more-matches-text":"mais correspondências neste documento","search-clear-button-title":"Limpar","search-text-placeholder":"","search-detached-cancel-button-title":"Cancelar","search-submit-button-title":"Enviar","search-label":"Procurar","toggle-section":"Alternar seção","toggle-sidebar":"Alternar barra lateral","toggle-dark-mode":"Alternar modo escuro","toggle-reader-mode":"Alternar modo de leitor","toggle-navigation":"Alternar de navegação","crossref-fig-title":"Figura","crossref-tbl-title":"Tabela","crossref-lst-title":"Listagem","crossref-thm-title":"Teorema","crossref-lem-title":"Lema","crossref-cor-title":"Corolário","crossref-prp-title":"Proposição","crossref-cnj-title":"Conjetura","crossref-def-title":"Definição","crossref-exm-title":"Exemplo","crossref-exr-title":"Exercício","crossref-ch-prefix":"Capítulo","crossref-apx-prefix":"Apêndice","crossref-sec-prefix":"Seção","crossref-eq-prefix":"Equação","crossref-lof-title":"Lista de Figuras","crossref-lot-title":"Lista de Tabelas","crossref-lol-title":"Lista de Listagens","environment-proof-title":"Comprovação","environment-remark-title":"Comentário","environment-solution-title":"Solução","listing-page-order-by":"Ordenar por","listing-page-order-by-default":"Pré-selecionado","listing-page-order-by-date-asc":"Mais velho","listing-page-order-by-date-desc":"O mais novo","listing-page-order-by-number-desc":"Decrescente","listing-page-order-by-number-asc":"Crescente","listing-page-field-date":"Data","listing-page-field-title":"Título","listing-page-field-description":"Descrição","listing-page-field-author":"Autor","listing-page-field-filename":"Nome do arquivo","listing-page-field-filemodified":"Arquivo modificado","listing-page-field-subtitle":"Subtítulo","listing-page-field-readingtime":"Tempo de leitura","listing-page-field-wordcount":"Contagem de Palavras","listing-page-field-categories":"Categorias","listing-page-minutes-compact":"{0} minutos","listing-page-category-all":"Tudo","listing-page-no-matches":"Nenhum item correspondente","listing-page-words":"{0} palavras","listing-page-filter":"Filtro","draft":"Rascunho"},"metadata":{"lang":"pt","fig-responsive":true,"quarto-version":"1.5.57","page-navigation":true,"page-footer":{"border":true,"left":"Copyright 2024, Beatriz Milz e IPEA/COCD","right":[{"icon":"github","href":"https://github.com/ipeadata-lab/curso_r_intro_202409s"}]},"bibliography":["references.bib"],"editor":"source","theme":"cosmo","title":"Transformando dados","code-annotations":"hover"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}